<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Frame Diary</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Caveat&family=Inter:wght@400;600;800&family=Lobster&family=Nanum+Pen+Script&family=Do+Hyeon&family=Gothic+A1&family=Permanent+Marker&family=Jua&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html, body { 
            overscroll-behavior-y: contain; 
            height: 100%;
        }
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #f3f4f6; 
            min-height: 100vh;
        }
        body {
            min-height: 100dvh; 
        }
        
        #canvasContainer { width: 100%; max-width: 420px; margin: 0 auto; position: relative; } 
        #photoCanvas {
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15); border: 1px solid #e5e7eb;
            display: block; width: 100%; height: auto; border-radius: 1rem;
        }
        
        #mainTextOverlay, #subTextOverlay {
            position: absolute; text-align: center; cursor: grab; user-select: none;
            z-index: 50; padding: 5px 10px; border-radius: 5px;
            transition: all 0.1s ease-out; 
            top: 0;
            left: 0;
            white-space: nowrap;
            opacity: 0;
            background-color: transparent;
            border: 1px dashed transparent;
        }
        
        .text-overlay.dragging {
            opacity: 1 !important;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px dashed #374151;
        }

        /* ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ìŠ¤íƒ€ì¼ */
        .preview-item.dragging {
            opacity: 0.4;
            border: 2px solid #3b82f6;
        }
        /* ëª¨ë°”ì¼ì—ì„œ ë¡±í”„ë ˆìŠ¤ ì‹œ ì„ íƒë˜ëŠ” ê²ƒ ë°©ì§€ */
        .preview-item {
            user-select: none;
            -webkit-user-drag: none;
            touch-action: none; /* ëª¨ë°”ì¼ ë“œë˜ê·¸ë¥¼ ìœ„í•´ í•„ìš” */
        }
        
        .tab-btn.active { border-color: #374151; color: #374151; font-weight: 700; }
        .control-btn {
            transition: all 0.2s ease-in-out; border: 1px solid #e5e7eb;
            padding: 1rem; min-width: 100px; text-align: center;
        }
        .control-btn.active {
            transform: scale(1.0); box-shadow: 0 0 0 3px rgba(55, 65, 81, 0.7);
            border-color: #374151; z-index: 10;
        }
        #textPositionButtons .control-btn.active { box-shadow: 0 0 0 2px rgba(55, 65, 81, 0.7); }
        #loader { backdrop-filter: blur(4px); }
        h1, h2, h3 { word-break: keep-all; }
        #dropZone.drag-over { border-color: #3b82f6; background-color: #eff6ff; }
        .preview-item.dragging { opacity: 0.5; transform: scale(0.95); }
        
        @media (max-width: 640px) {
            .control-btn {
                padding: 0.75rem;
                min-width: 80px; 
            }
        }

        @media (hover: hover) and (pointer: fine) {
            .text-overlay:hover:not(.dragging) { 
                background-color: rgba(255, 255, 255, 0.2); 
                border: 1px dashed rgba(55, 65, 81, 0.5); 
                opacity: 1; 
            }
        }
    </style>
</head>
<body class="min-h-screen">

    <div class="w-full max-w-7xl mx-auto bg-white lg:rounded-3xl lg:shadow-2xl lg:my-8 overflow-hidden">
        
        <header class="text-center py-6 border-b border-gray-100 lg:hidden">
            <h1 class="text-3xl font-black text-gray-900">Frame Diary</h1>
            <p class="text-gray-400 text-sm">ë‚˜ë§Œì˜ ì¶”ì–µì„ ë‹´ì€ í¬í† ë¶</p>
        </header>
        
        <main class="flex flex-col lg:flex-row lg:gap-12 lg:p-10">
            
            <div class="w-full lg:w-2/5 p-4 lg:p-0 lg:sticky lg:top-10 self-start">
                <header class="hidden lg:block mb-8 mt-4">
                    <h1 class="text-5xl font-extrabold text-gray-900 tracking-tighter">Frame Diary</h1>
                    <p class="text-xl text-gray-500 mt-1">ì‚¬ì§„ìœ¼ë¡œ íŠ¹ë³„í•œ ìˆœê°„ì„ ë‹´ë‹¤</p>
                </header>
                <div id="canvasContainer">
                    <canvas id="photoCanvas"></canvas>
                    <div id="mainTextOverlay" class="text-overlay"></div>
                    <div id="subTextOverlay" class="text-overlay"></div>
                </div>
            </div>

            <div class="w-full lg:w-3/5">
                <nav class="flex border-b border-gray-200">
                    <button class="tab-btn active flex-1 p-4 font-medium border-b-4 border-transparent text-gray-500 flex items-center justify-center gap-2" data-tab="tab-photo">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 15H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" /></svg>
                        ì‚¬ì§„ ì¶”ê°€
                    </button>
                    <button class="tab-btn flex-1 p-4 font-medium border-b-4 border-transparent text-gray-500 flex items-center justify-center gap-2" data-tab="tab-design">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" /></svg>
                        ë ˆì´ì•„ì›ƒ & ìŠ¤íƒ€ì¼
                    </button>
                    <button class="tab-btn flex-1 p-4 font-medium border-b-4 border-transparent text-gray-500 flex items-center justify-center gap-2" data-tab="tab-text">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H4a1 1 0 110-2V4zm3 1h2v1H7V5zm0 2h2v1H7V7z" clip-rule="evenodd" /></svg>
                        í…ìŠ¤íŠ¸ ê¾¸ë¯¸ê¸°
                    </button>
                     <button class="tab-btn flex-1 p-4 font-medium border-b-4 border-transparent text-gray-500 flex items-center justify-center gap-2" data-tab="tab-save">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                        ì €ì¥í•˜ê¸°
                    </button>
                </nav>

                <div class="p-6 space-y-8">
                    <div id="tab-photo" class="tab-content space-y-4">
                        <div id="dropZone" class="w-full p-6 border-2 border-dashed border-gray-300 rounded-2xl text-center cursor-pointer hover:border-blue-500 hover:bg-gray-50 transition-colors">
                            <p class="font-bold text-gray-600">ğŸ‘‡ ì‚¬ì§„ì„ ì—¬ê¸°ì— ëŒì–´ì„œ ë†“ìœ¼ì„¸ìš”</p>
                            <p class="text-sm text-gray-400 mt-1">ë˜ëŠ” ì•„ë˜ ë²„íŠ¼ìœ¼ë¡œ ì„ íƒí•´ì£¼ì„¸ìš”</p>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <label for="imageUpload" class="w-full bg-gray-900 text-white p-4 rounded-2xl font-bold text-center cursor-pointer hover:bg-gray-800 transition-colors shadow-lg transform hover:scale-[1.01]">ğŸ“± íœ´ëŒ€í°ì—ì„œ ì„ íƒ</label>
                            <label for="cameraUpload" class="w-full bg-gray-700 text-white p-4 rounded-2xl font-bold text-center cursor-pointer hover:bg-gray-600 transition-colors shadow-lg transform hover:scale-[1.01]">ğŸ“¸ ì§€ê¸ˆ ë°”ë¡œ ì´¬ì˜</label>
                            <input type="file" id="imageUpload" multiple accept="image/*" class="hidden">
                            <input type="file" id="cameraUpload" accept="image/*" capture="user" class="hidden">
                        </div>
                        <div id="imagePreviewsContainer" class="space-y-4">
                            <p id="fileStatus" class="text-sm text-gray-500 h-5"></p> 
                            <div id="imagePreviews" class="grid grid-cols-3 sm:grid-cols-6 gap-4"></div>
                        </div>
                    </div>

                    <div id="tab-design" class="tab-content hidden space-y-6">
                        <div>
                           <h3 class="font-bold text-lg mb-2 text-gray-800">ğŸ“ ì‚¬ì§„ ë°°ì¹˜ ë°©ì‹</h3>
                           <div id="layoutButtons" class="grid grid-cols-3 gap-4">
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md active" data-layout="1x4">ì„¸ë¡œ<br/>4ì¥</button>
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md" data-layout="2x2">ì •ì‚¬ê°<br/>4ì¥</button>
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md" data-layout="1+3">í¼+ì‘ìŒ<br/>4ì¥</button>
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md" data-layout="2+3">í˜¼í•©<br/>5ì¥</button>
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md" data-layout="2x3">ì„¸ë¡œ<br/>6ì¥</button>
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md" data-layout="3x2">ê°€ë¡œ<br/>6ì¥</button>
                            </div>
                        </div>
                         <div>
                            <h3 class="font-bold text-lg mb-2 text-gray-800">ğŸ¨ í…Œë§ˆ í”„ë¦¬ì…‹ (ì›í´ë¦­ ìŠ¤íƒ€ì¼)</h3>
                            <div id="themeButtons" class="grid grid-cols-3 sm:grid-cols-4 gap-4"></div>
                        </div>
                        <div>
                            <h3 class="font-bold text-lg mb-2 text-gray-800">âš™ï¸ ìƒì„¸ ì˜µì…˜</h3>
                            <div class="space-y-4">
                                <div>
                                    <label for="frameMarginSlider" class="font-semibold text-gray-600">ë°”ê¹¥ìª½ ì—¬ë°±: <span id="frameMarginValue">5</span>%</label>
                                    <input type="range" id="frameMarginSlider" min="0" max="20" value="5" class="w-full mt-2 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                                </div>
                                 <div>
                                    <label for="imagePaddingSlider" class="font-semibold text-gray-600">ì‚¬ì§„ ì‚¬ì´ ê°„ê²©: <span id="imagePaddingValue">5</span>%</label>
                                    <input type="range" id="imagePaddingSlider" min="0" max="20" value="5" class="w-full mt-2 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                                </div>
                                <div>
                                    <label for="imageRadiusSlider" class="font-semibold text-gray-600">ì‚¬ì§„ ëª¨ì„œë¦¬ ê³¡ì„ : <span id="imageRadiusValue">0</span>px</label>
                                    <input type="range" id="imageRadiusSlider" min="0" max="50" value="0" class="w-full mt-2 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                                </div>
                            </div>
                        </div>
                        <div>
                           <h3 class="font-bold text-lg mb-2 text-gray-800">ğŸŒˆ ìƒ‰ìƒ ì¡°ì •</h3>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="backgroundColorPicker" class="font-semibold text-gray-600 text-sm">ë°°ê²½ ìƒ‰</label>
                                    <input type="color" id="backgroundColorPicker" class="w-full h-10 p-1 mt-1 border rounded-md cursor-pointer hover:shadow-md">
                                </div>
                                <div>
                                    <label for="frameColorPicker" class="font-semibold text-gray-600 text-sm">í…Œë‘ë¦¬ ìƒ‰</label>
                                    <input type="color" id="frameColorPicker" class="w-full h-10 p-1 mt-1 border rounded-md cursor-pointer hover:shadow-md">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="tab-text" class="tab-content hidden space-y-6">
                         <h3 class="font-bold text-lg mb-4 text-gray-800">âœï¸ ì œëª©ê³¼ ì„¤ëª… ê¸€ê·€</h3>
                         <p class="text-sm text-blue-600 font-medium bg-blue-50 p-3 rounded-lg border border-blue-100">
                             ğŸ’¡ ìº”ë²„ìŠ¤ì—ì„œ ê¸€ê·€ë¥¼ ëˆŒëŸ¬ ë“œë˜ê·¸í•˜ë©´ ì›í•˜ëŠ” ìœ„ì¹˜ë¡œ ììœ ë¡­ê²Œ ì˜®ê¸¸ ìˆ˜ ìˆì–´ìš”.
                         </p>

                        <input type="text" id="customTextInput" placeholder="ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: SUMMER MEMORIES)" value="LIFE 4 CUTS" class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-gray-300 focus:border-gray-500 transition-shadow">
                        <input type="text" id="subTextInput" placeholder="ë‚ ì§œë‚˜ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: 2024ë…„ 8ì›”)" class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-gray-300 focus:border-gray-500 transition-shadow">
                        
                        <div class="space-y-3">
                            <h4 class="font-semibold text-gray-600">ì œëª©ì´ ì²˜ìŒ ë‚˜íƒ€ë‚  ìœ„ì¹˜ (í´ë¦­í•´ì„œ ë“œë˜ê·¸ë¡œ ì´ë™ ê°€ëŠ¥)</h4>
                            <div id="textPositionButtons" class="flex gap-2 sm:gap-4">
                                <button class="control-btn p-2 rounded-xl shadow-sm font-semibold text-sm w-1/3" data-position="top">ìœ„ìª½</button>
                                <button class="control-btn p-2 rounded-xl shadow-sm font-semibold text-sm w-1/3" data-position="center">ì¤‘ì•™</button>
                                <button class="control-btn p-2 rounded-xl shadow-sm font-semibold text-sm w-1/3 active" data-position="bottom">ì•„ë˜ìª½</button>
                            </div>
                        </div>
                        
                        <div class="p-4 border rounded-xl space-y-4 bg-gray-50">
                            <h4 class="font-bold text-md text-gray-700">ğŸ“ ì œëª© ìŠ¤íƒ€ì¼</h4>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="mainFontSelector" class="font-semibold text-gray-600 text-sm">ê¸€ê¼´</label>
                                    <select id="mainFontSelector" class="w-full p-2 mt-1 border rounded-md focus:ring-2 focus:ring-gray-300"></select>
                                </div>
                                <div>
                                    <label for="mainFontColorPicker" class="font-semibold text-gray-600 text-sm">ê¸€ì ìƒ‰</label>
                                    <input type="color" id="mainFontColorPicker" class="w-full h-10 p-1 mt-1 border rounded-md cursor-pointer hover:shadow-md">
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="mainTextStrokeColorPicker" class="font-semibold text-gray-600 text-sm">í…Œë‘ë¦¬ ìƒ‰</label>
                                    <input type="color" id="mainTextStrokeColorPicker" value="#FFFFFF" class="w-full h-10 p-1 mt-1 border rounded-md cursor-pointer hover:shadow-md">
                                </div>
                                <div>
                                    <label for="mainTextStrokeSlider" class="font-semibold text-gray-600 text-sm">í…Œë‘ë¦¬ êµµê¸°: <span id="mainTextStrokeValue">0</span>px</label>
                                    <input type="range" id="mainTextStrokeSlider" min="0" max="10" value="0" class="w-full mt-1 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                                </div>
                            </div>
                            <div>
                                <label for="mainFontSizeSlider" class="font-semibold text-gray-600">ê¸€ì í¬ê¸°: <span id="mainFontSizeValue">50</span>px</label>
                                <input type="range" id="mainFontSizeSlider" min="20" max="150" value="50" class="w-full mt-2 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                            </div>
                        </div>

                        <div class="p-4 border rounded-xl space-y-4 bg-gray-50">
                            <h4 class="font-bold text-md text-gray-700">ğŸ“Œ ì„¤ëª… ê¸€ ìŠ¤íƒ€ì¼</h4>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="subFontSelector" class="font-semibold text-gray-600 text-sm">ê¸€ê¼´</label>
                                    <select id="subFontSelector" class="w-full p-2 mt-1 border rounded-md focus:ring-2 focus:ring-gray-300"></select>
                                </div>
                                <div>
                                    <label for="subFontColorPicker" class="font-semibold text-gray-600 text-sm">ê¸€ì ìƒ‰</label>
                                    <input type="color" id="subFontColorPicker" class="w-full h-10 p-1 mt-1 border rounded-md cursor-pointer hover:shadow-md">
                                </div>
                            </div>
                            <div>
                                <label for="subFontSizeSlider" class="font-semibold text-gray-600">ê¸€ì í¬ê¸°: <span id="subFontSizeValue">25</span>px</label>
                                <input type="range" id="subFontSizeSlider" min="10" max="75" value="25" class="w-full mt-2 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                            </div>
                        </div>
                    </div>
                     <div id="tab-save" class="tab-content hidden space-y-4">
                        <p class="text-center text-gray-600 text-lg font-medium">âœ¨ ì‘í’ˆì´ ì™„ì„±ë˜ì—ˆì–´ìš”!<br/>ì›í•˜ëŠ” í˜•ì‹ìœ¼ë¡œ ì €ì¥í•˜ì„¸ìš”</p>
                        <button id="downloadPngBtn" class="w-full bg-blue-600 text-white p-4 rounded-xl font-bold text-lg shadow-xl hover:bg-blue-700 transition-all duration-300 transform hover:scale-[1.01]">
                            ğŸ–¼ï¸ PNGë¡œ ì €ì¥ (ìµœê³  í™”ì§ˆ - ì¶”ì²œ)
                        </button>
                        <button id="downloadJpgBtn" class="w-full bg-gray-800 text-white p-4 rounded-xl font-bold text-lg shadow-xl hover:bg-gray-900 transition-all duration-300 transform hover:scale-[1.01]">
                            ğŸ“· JPEGë¡œ ì €ì¥ (ì¼ë°˜ í™”ì§ˆ)
                        </button>
                        <div class="pt-4">
                            <button id="resetBtn" class="w-full bg-red-500 text-white p-3 rounded-xl font-semibold text-base shadow-lg hover:bg-red-600 transition-all duration-300 transform hover:scale-[1.01]">
                                ğŸ”„ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•˜ê¸°
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <div id="loader" class="fixed inset-0 bg-white bg-opacity-75 hidden justify-center items-center z-50">
        <div class="w-16 h-16 border-4 border-gray-900 border-t-transparent rounded-full animate-spin"></div>
    </div>

    <script>
        // --- ì „ì—­ ë³€ìˆ˜ ë° ì„¤ì • ---
        const MAX_IMAGES = 6;
        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        const mainTextOverlay = document.getElementById('mainTextOverlay');
        const subTextOverlay = document.getElementById('subTextOverlay');
        let draggedItem = null;
        let isDraggingText = false; // í…ìŠ¤íŠ¸ ë“œë˜ê·¸ ì¤‘ì¸ì§€ í™•ì¸í•˜ëŠ” í”Œë˜ê·¸

        // ğŸ¨ í…Œë§ˆ í”„ë¦¬ì…‹ (ìƒì—…ì  ë””ìì¸ ê¸°ì¤€ ê°•í™” ë° í¬ë¦¬ìŠ¤ë§ˆìŠ¤ ì¶”ê°€)
        const themes = {
            'modern-matte': { name: 'âœ¨ ëª¨ë˜ ë§¤íŠ¸', bg: '#f7f7f7', frame: '#ffffff', text: '#333333', font: 'Noto Sans KR' },
            'dark-edition': { name: 'ğŸŒ‘ ë‹¤í¬ ì—ë””ì…˜', bg: '#1A1A1A', frame: '#333333', text: '#EDEDED', font: 'Inter' },
            'christmas-dream': { name: 'ğŸ„ í¬ë¦¬ìŠ¤ë§ˆìŠ¤ ë“œë¦¼', bg: '#F8F8F8', frame: '#C0392B', text: '#1E8449', font: 'Permanent Marker' },
            'film-sepia': { name: 'ğŸï¸ ë¹ˆí‹°ì§€ í•„ë¦„', bg: '#E8D5C4', frame: '#fffaf2', text: '#584B3C', filter: 'sepia', font: 'Nanum Pen Script' },
            'monochrome': { name: 'âš«ï¸ ëª¨ë…¸í¬ë¡¬', bg: '#e5e5e5', frame: '#f9f9f9', text: '#0a0a0a', filter: 'grayscale', font: 'Gothic A1' },
            'cozy-coffee': { name: 'â˜•ï¸ í¬ê·¼í•œ ì¹´í˜', bg: '#F9F5E9', frame: '#FFFFFF', text: '#6D4C41', font: 'Caveat' },
            'vibrant-retro': { name: 'ğŸ’– ë„¤ì˜¨ íŒ', bg: '#FFE3E3', frame: '#F0F0FF', text: '#8A2BE2', font: 'Jua' },
            'spring-blossom': { name: 'ğŸŒ¸ ë²šê½ƒ ì—ë””ì…˜', bg: '#FFFAFF', frame: '#FFE4E1', text: '#DB7093', font: 'Gothic A1' },
            'deep-ocean': { name: 'ğŸŒŠ ë”¥ ì˜¤ì…˜', bg: '#004D73', frame: '#FFFFFF', text: '#FFC300', font: 'Lobster' },
            'korean-classic': { name: 'ğŸ‡°ğŸ‡· í•œêµ­ì˜ ë¯¸', bg: '#F3EFE9', frame: '#FFFFFF', text: '#3C583C', font: 'Do Hyeon' },
            'travel-blue': { name: 'âœˆï¸ íŠ¸ë˜ë¸” ë¸”ë£¨', bg: '#ADD8E6', frame: '#FFFFFF', text: '#004D73', font: 'Inter' },
            'summer-vivid': { name: 'â˜€ï¸ ì¨ë¨¸ ë¹„ë¹„ë“œ', bg: '#00bcd4', frame: '#FFFFFF', text: '#facc15', font: 'Jua' },
            'earth-tone': { name: 'ğŸ‚ ì–¼ìŠ¤í†¤ ë¬´ë“œ', bg: '#DBC3A0', frame: '#FFFFFF', text: '#4A4E69', font: 'Gothic A1' },
            'cyber-punk': { name: 'ğŸ‘¾ ì‚¬ì´ë²„ í‘í¬', bg: '#231942', frame: '#5E548E', text: '#9F86C0', font: 'Inter' },
            'pastel-lavender': { name: 'ğŸ’œ íŒŒìŠ¤í…” ë¼ë²¤ë”', bg: '#EBEBF8', frame: '#F0F0F8', text: '#6A5ACD', font: 'Noto Sans KR' },
        };
        
        // === getCurrentDateFormatted ===
        // ì˜¤ëŠ˜ ë‚ ì§œë¥¼ "2025. 12. 22."ì²˜ëŸ¼ ì˜ˆì˜ê²Œ ë§Œë“¤ì–´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ì•±ì„ ì²˜ìŒ ì¼œê±°ë‚˜ ìƒˆë¡œ ì‹œì‘í•  ë•Œ ë‚ ì§œë¥¼ ìë™ìœ¼ë¡œ ë„£ì–´ì¤˜ìš”.
        function getCurrentDateFormatted() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0'); // 0-indexed
            const day = String(now.getDate()).padStart(2, '0');
            return `${year}. ${month}. ${day}.`;
        }

        let defaultConfig = {
            images: [], 
            layout: '1x4',
            theme: 'modern-matte', 
            backgroundColor: themes['modern-matte'].bg,
            frameColor: themes['modern-matte'].frame,
            frameMargin: 5, // %
            imagePadding: 5, // %
            imageCornerRadius: 0, // NEW: ì‚¬ì§„ ëª¨ì„œë¦¬ ë‘¥ê¸€ê¸° (px)
            mainText: {
                content: 'LIFE 4 CUTS', font: 'Noto Sans KR', size: 50, 
                color: themes['modern-matte'].text, position: 'bottom', x: 0.5, y: 0,
                strokeColor: '#FFFFFF', // NEW: í…Œë‘ë¦¬ ìƒ‰ìƒ
                strokeWidth: 0 // NEW: í…Œë‘ë¦¬ ë‘ê»˜
            },
            subText: {
                // í˜„ì¬ ë‚ ì§œë¡œ ìë™ ì„¤ì •
                content: getCurrentDateFormatted(), 
                font: 'Noto Sans KR', size: 25, color: themes['modern-matte'].text, x: 0.5, y: 0 
            }
        };
        let config = JSON.parse(JSON.stringify(defaultConfig));
        
        // --- í°íŠ¸ ëª©ë¡ (JSë¡œ ê´€ë¦¬, íŠ¸ë Œë”” í°íŠ¸ ì¶”ê°€) ---
        const fontList = [
            { value: 'Inter', name: 'Inter (ê¸°ë³¸ ì˜ë¬¸)' },
            { value: 'Noto Sans KR', name: 'ë³¸ê³ ë”• (ê¹”ë”/ëª¨ë˜)' },
            { value: 'Jua', name: 'ì£¼ì•„ (êµµì€ ì œëª©)' },
            { value: 'Nanum Pen Script', name: 'ë‚˜ëˆ”ì†ê¸€ì”¨ íœ' },
            { value: 'Gothic A1', name: 'ê³ ë”• A1 (ëª¨ë˜)' },
            { value: 'Do Hyeon', name: 'ë„í˜„ (í•œêµ­ì )' },
            { value: 'Caveat', name: 'Caveat (í•„ê¸°ì²´)' },
            { value: 'Lobster', name: 'Lobster (ì˜ë¬¸ ì œëª©)' },
            { value: 'Permanent Marker', name: 'Permanent Marker' },
        ];


        // --- ì´ˆê¸°í™” ---
        window.onload = () => {
            setupEventListeners();
            populateThemeButtons();
            populateFontSelectors(); 
            updateUIFromConfig();
            setupTabs();
            // ìº”ë²„ìŠ¤ ì´ˆê¸° í¬ê¸° ì„¤ì • í›„ ë“œë¡œì‰
            setTimeout(() => {
                resizeCanvas();
                if (config.mainText.y === 0) initializeTextPositions();
                drawCanvas(); 
            }, 500); 
        };

        // === populateFontSelectors ===
        // ê¸€ì”¨ì²´ ê³ ë¥´ëŠ” ë©”ë‰´(ë“œë¡­ë‹¤ìš´)ë¥¼ ì±„ì›Œì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ë©”ì¸ ê¸€ìì™€ ì‘ì€ ê¸€ì ëª¨ë‘ ê°™ì€ ê¸€ì”¨ì²´ ëª©ë¡ì„ ë³´ì—¬ì¤˜ìš”.
        function populateFontSelectors() {
            const mainSelector = document.getElementById('mainFontSelector');
            const subSelector = document.getElementById('subFontSelector');
            
            // ê¸°ì¡´ ì˜µì…˜ ì œê±°
            mainSelector.innerHTML = '';
            subSelector.innerHTML = '';

            fontList.forEach(font => {
                const mainOption = new Option(font.name, font.value);
                const subOption = new Option(font.name, font.value);
                mainSelector.add(mainOption);
                subSelector.add(subOption);
            });
        }

        // === setupEventListeners ===
        // ì•±ì—ì„œ ë²„íŠ¼ ëˆ„ë¥´ê¸°, ì‚¬ì§„ ì˜¬ë¦¬ê¸°, ìŠ¬ë¼ì´ë” ì›€ì§ì´ê¸°, ê¸€ì ì“°ê¸° ë“± ëª¨ë“  ë™ì‘ì„ ê°ì§€í•´ì„œ "ì´ê±¸ ëˆ„ë¥´ë©´ ì´ ì¼ì´ ì¼ì–´ë‚˜!"ë¼ê³  ì—°ê²°í•´ ì£¼ëŠ” í° í•¨ìˆ˜ì˜ˆìš”.
        function setupEventListeners() {
            // ì´ë¯¸ì§€ ì—…ë¡œë“œ
            const dropZone = document.getElementById('dropZone');
            dropZone.addEventListener('click', () => document.getElementById('imageUpload').click());
            dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drag-over'); });
            dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('drag-over'); });
            dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('drag-over'); handleFiles(e.dataTransfer.files); });
            document.getElementById('imageUpload').addEventListener('change', (e) => handleFiles(e.target.files));
            document.getElementById('cameraUpload').addEventListener('change', (e) => handleFiles(e.target.files));

            // ë””ìì¸
            document.getElementById('layoutButtons').addEventListener('click', (e) => {
                let targetButton = e.target.closest('.control-btn');
                if (targetButton) { 
                    config.layout = targetButton.dataset.layout; 
                    updateActiveButton(document.getElementById('layoutButtons'), targetButton); 
                    resizeCanvas(); 
                    initializeTextPositions(); 
                    drawCanvas(); 
                }
            });
            document.getElementById('frameMarginSlider').addEventListener('input', (e) => { config.frameMargin = parseInt(e.target.value); document.getElementById('frameMarginValue').textContent = e.target.value; drawCanvas(); });
            document.getElementById('imagePaddingSlider').addEventListener('input', (e) => { config.imagePadding = parseInt(e.target.value); document.getElementById('imagePaddingValue').textContent = e.target.value; drawCanvas(); });
            // NEW LISTENER: Image Corner Radius
            document.getElementById('imageRadiusSlider').addEventListener('input', (e) => { config.imageCornerRadius = parseInt(e.target.value); document.getElementById('imageRadiusValue').textContent = e.target.value; drawCanvas(); });
            
            document.getElementById('backgroundColorPicker').addEventListener('input', (e) => { config.backgroundColor = e.target.value; drawCanvas(); });
            document.getElementById('frameColorPicker').addEventListener('input', (e) => { config.frameColor = e.target.value; drawCanvas(); });
            
            // í…ìŠ¤íŠ¸ ìœ„ì¹˜ ì„¤ì •
            document.getElementById('textPositionButtons').addEventListener('click', (e) => {
                let targetButton = e.target.closest('button');
                if (targetButton && targetButton.dataset.position) { 
                    config.mainText.position = targetButton.dataset.position; 
                    updateActiveButton(document.getElementById('textPositionButtons'), targetButton); 
                    initializeTextPositions(); 
                    drawCanvas(); 
                }
            });
            document.getElementById('customTextInput').addEventListener('input', (e) => { config.mainText.content = e.target.value; updateTextOverlay(); drawCanvas(); });
            document.getElementById('subTextInput').addEventListener('input', (e) => { config.subText.content = e.target.value; updateTextOverlay(); drawCanvas(); });
            
            
            // --- ë©”ì¸ ë¬¸êµ¬ ì „ìš© ë¦¬ìŠ¤ë„ˆ ---
            document.getElementById('mainFontSelector').addEventListener('change', (e) => { 
                config.mainText.font = e.target.value; 
                updateTextOverlay(); drawCanvas(); 
            });
            document.getElementById('mainFontSizeSlider').addEventListener('input', (e) => {
                config.mainText.size = parseInt(e.target.value);
                document.getElementById('mainFontSizeValue').textContent = e.target.value;
                updateTextOverlay(); drawCanvas();
            });
            document.getElementById('mainFontColorPicker').addEventListener('input', (e) => { 
                config.mainText.color = e.target.value; 
                updateTextOverlay(); drawCanvas(); 
            });
            // NEW LISTENER: Main Text Stroke
            document.getElementById('mainTextStrokeColorPicker').addEventListener('input', (e) => { 
                config.mainText.strokeColor = e.target.value; 
                updateTextOverlay(); drawCanvas(); 
            });
            document.getElementById('mainTextStrokeSlider').addEventListener('input', (e) => {
                config.mainText.strokeWidth = parseInt(e.target.value);
                document.getElementById('mainTextStrokeValue').textContent = e.target.value;
                updateTextOverlay(); drawCanvas();
            });


            // --- ë³´ì¡° ë¬¸êµ¬ ì „ìš© ë¦¬ìŠ¤ë„ˆ ---
            document.getElementById('subFontSelector').addEventListener('change', (e) => { 
                config.subText.font = e.target.value; 
                updateTextOverlay(); drawCanvas(); 
            });
            document.getElementById('subFontSizeSlider').addEventListener('input', (e) => {
                config.subText.size = parseInt(e.target.value);
                document.getElementById('subFontSizeValue').textContent = e.target.value;
                updateTextOverlay(); drawCanvas();
            });
            document.getElementById('subFontColorPicker').addEventListener('input', (e) => { 
                config.subText.color = e.target.value; 
                updateTextOverlay(); drawCanvas(); 
            });

            // ì €ì¥
            // ğŸ’¡ [ì—…ê·¸ë ˆì´ë“œ] PNG ë²„íŠ¼: ëª¨ë°”ì¼ í™˜ê²½ì—ì„œ ê°¤ëŸ¬ë¦¬ ì €ì¥ ì‹œë„
            document.getElementById('downloadPngBtn').addEventListener('click', async () => {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) {
                    await saveToGallery('png');
                } else {
                    downloadImage('png');
                }
            });
            
            // ğŸ’¡ [ì—…ê·¸ë ˆì´ë“œ] JPEG ë²„íŠ¼: ëª¨ë°”ì¼ í™˜ê²½ì—ì„œ ê°¤ëŸ¬ë¦¬ ì €ì¥ ì‹œë„
            document.getElementById('downloadJpgBtn').addEventListener('click', async () => {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) {
                    await saveToGallery('jpeg'); 
                } else {
                    downloadImage('jpeg');
                }
            });
            document.getElementById('resetBtn').addEventListener('click', () => { if(confirm('ì •ë§ë¡œ ëª¨ë“  ì‘ì—…ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) resetApp(); });

            // í…ìŠ¤íŠ¸ ë“œë˜ê·¸ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            addTextDragListeners(mainTextOverlay, 'mainText');
            addTextDragListeners(subTextOverlay, 'subText');
        }

        // === updateUIFromConfig ===
        // ì§€ê¸ˆ ì„¤ì •í•œ ëª¨ë“  ê²ƒ(ìƒ‰ê¹”, ê¸€ì”¨ í¬ê¸°, ìœ„ì¹˜ ë“±)ì„ í™”ë©´ì˜ ë²„íŠ¼ê³¼ ìŠ¬ë¼ì´ë”ì— ë˜‘ê°™ì´ ë³´ì—¬ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ì„¤ì • ë°”ê¾¸ë©´ ë°”ë¡œ í™”ë©´ë„ ë°”ë€Œê²Œ í•´ì¤˜ìš”.
        function updateUIFromConfig() {
            // í…Œë§ˆ ë° ë ˆì´ì•„ì›ƒ, ìœ„ì¹˜ ë²„íŠ¼ í™œì„±í™”
            updateActiveButton(document.getElementById('themeButtons'), document.querySelector(`[data-theme="${config.theme}"]`));
            updateActiveButton(document.getElementById('layoutButtons'), document.querySelector(`[data-layout="${config.layout}"]`));
            updateActiveButton(document.getElementById('textPositionButtons'), document.querySelector(`[data-position="${config.mainText.position}"]`));
            
            // ìƒ‰ìƒ ë° ë§ˆì§„ ìŠ¬ë¼ì´ë”
            document.getElementById('backgroundColorPicker').value = config.backgroundColor;
            document.getElementById('frameColorPicker').value = config.frameColor;
            document.getElementById('frameMarginSlider').value = config.frameMargin;
            document.getElementById('frameMarginValue').textContent = config.frameMargin;
            document.getElementById('imagePaddingSlider').value = config.imagePadding;
            document.getElementById('imagePaddingValue').textContent = config.imagePadding;
            // NEW UI UPDATE: Image Corner Radius
            document.getElementById('imageRadiusSlider').value = config.imageCornerRadius;
            document.getElementById('imageRadiusValue').textContent = config.imageCornerRadius;

            // í…ìŠ¤íŠ¸ ë‚´ìš©
            document.getElementById('customTextInput').value = config.mainText.content;
            document.getElementById('subTextInput').value = config.subText.content; // í˜„ì¬ ë‚ ì§œë¡œ ì´ˆê¸°í™”ëœ ê°’ ì‚¬ìš©
            
            // ë©”ì¸ í…ìŠ¤íŠ¸ UI ì—…ë°ì´íŠ¸
            document.getElementById('mainFontSelector').value = config.mainText.font;
            document.getElementById('mainFontSizeSlider').value = config.mainText.size;
            document.getElementById('mainFontSizeValue').textContent = config.mainText.size;
            document.getElementById('mainFontColorPicker').value = config.mainText.color;
            // NEW UI UPDATE: Main Text Stroke
            document.getElementById('mainTextStrokeColorPicker').value = config.mainText.strokeColor;
            document.getElementById('mainTextStrokeSlider').value = config.mainText.strokeWidth;
            document.getElementById('mainTextStrokeValue').textContent = config.mainText.strokeWidth;
            
            // ë³´ì¡° í…ìŠ¤íŠ¸ UI ì—…ë°ì´íŠ¸
            document.getElementById('subFontSelector').value = config.subText.font;
            document.getElementById('subFontSizeSlider').value = config.subText.size;
            document.getElementById('subFontSizeValue').textContent = config.subText.size;
            document.getElementById('subFontColorPicker').value = config.subText.color;
            
            updateTextOverlay(); // ì˜¤ë²„ë ˆì´ ìœ„ì¹˜/ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
        }


        // === resetApp ===
        // "ì²˜ìŒìœ¼ë¡œ!" ë²„íŠ¼ì²˜ëŸ¼ ëª¨ë“  ê±¸ ê¹¨ë—ì´ ì§€ìš°ê³  ì²˜ìŒ ìƒíƒœë¡œ ëŒë ¤ë†“ëŠ” í•¨ìˆ˜ì˜ˆìš”. ì‚¬ì§„ë„ ì—†ì• ê³  ë‚ ì§œë„ ì˜¤ëŠ˜ë¡œ ë‹¤ì‹œ ë„£ì–´ìš”.
        function resetApp() {
            // ë¦¬ì…‹ ì‹œì—ë„ í˜„ì¬ ë‚ ì§œë¡œ ì´ˆê¸°í™”
            defaultConfig.subText.content = getCurrentDateFormatted(); 
            config = JSON.parse(JSON.stringify(defaultConfig));
            updateUIFromConfig();
            renderImagePreviews();
            resizeCanvas();
            initializeTextPositions();
            drawCanvas();
        }

        // === setupTabs ===
        // ìœ„ì— ìˆëŠ” íƒ­(ì‚¬ì§„ ê´€ë¦¬, ë””ìì¸, í…ìŠ¤íŠ¸, ì €ì¥)ì„ ëˆ„ë¥´ë©´ í•´ë‹¹ í˜ì´ì§€ë§Œ ë³´ì—¬ì£¼ê³  ë‚˜ë¨¸ì§€ëŠ” ìˆ¨ê¸°ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function setupTabs() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.dataset.tab;
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    tabContents.forEach(content => content.id === tabId ? content.classList.remove('hidden') : content.classList.add('hidden'));
                });
            });
        }

        // === populateThemeButtons ===
        // ì˜ˆìœ í…Œë§ˆ(ìƒ‰ ì¡°í•©) ë²„íŠ¼ë“¤ì„ ìë™ìœ¼ë¡œ ë§Œë“¤ì–´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ë²„íŠ¼ ëˆ„ë¥´ë©´ ë°°ê²½ìƒ‰, ê¸€ììƒ‰, í”„ë ˆì„ìƒ‰ì´ í•œ ë²ˆì— ë°”ë€Œì–´ìš”.
        function populateThemeButtons() {
            const container = document.getElementById('themeButtons');
            container.innerHTML = '';
            for (const [key, theme] of Object.entries(themes)) {
                const button = document.createElement('button');
                button.className = 'control-btn p-3 rounded-xl shadow-sm border text-sm font-semibold transition-all duration-200 text-center bg-white hover:shadow-md';
                // í…Œë§ˆ ìƒ‰ìƒì„ ë” ì˜ ë³´ì—¬ì£¼ê¸° ìœ„í•´ í”„ë ˆì„ ìƒ‰ìƒì´ í°ìƒ‰ì¼ ê²½ìš° í…Œë‘ë¦¬ë¥¼ ì§€ì •
                const frameBorderColor = theme.frame === '#ffffff' || theme.frame === '#f9f9f9' || theme.frame === '#fffaf2' || theme.frame === '#F0F0F8' ? '#d1d5db' : theme.frame;
                button.innerHTML = `<div class="w-full h-4 rounded mb-2 border-2" style="background-color: ${theme.bg}; border-color: ${frameBorderColor};"></div>${theme.name}`;
                button.dataset.theme = key;
                button.addEventListener('click', () => {
                    config.theme = key; 
                    config.backgroundColor = theme.bg; 
                    config.frameColor = theme.frame;
                    config.mainText.color = theme.text; 
                    config.subText.color = theme.text;
                    
                    if(theme.font) {
                        config.mainText.font = theme.font;
                        config.subText.font = theme.font;
                    } else { // í°íŠ¸ê°€ ì§€ì •ë˜ì§€ ì•Šì€ ê²½ìš° ê¸°ë³¸ í°íŠ¸ë¥¼ ì‚¬ìš©
                        config.mainText.font = 'Noto Sans KR';
                        config.subText.font = 'Noto Sans KR';
                    }
                    
                    // í•„í„° ì„¤ì •
                    const newFilter = theme.filter || null;
                    config.images = config.images.map(img => ({...img, filter: newFilter}));
                    
                    updateUIFromConfig(); 
                    drawCanvas();
                    renderImagePreviews(); // ë¯¸ë¦¬ë³´ê¸°ì—ë„ í•„í„°ë¥¼ ì ìš©í•´ì•¼ í•˜ë¯€ë¡œ í˜¸ì¶œ
                });
                container.appendChild(button);
            }
        }
        
        function updateActiveButton(container, activeButton) {
            container.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
            if (activeButton) activeButton.classList.add('active');
        }

        // --- ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì ˆ í•¨ìˆ˜ ---
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            let aspectRatio;
            switch(config.layout) {
                case '1x4': aspectRatio = 3; break;
                case '2x2': aspectRatio = 1.5; break;
                case '1+3': aspectRatio = 2; break; 
                case '2+3': aspectRatio = 1.8; break; 
                case '2x3': aspectRatio = 2.2; break; 
                case '3x2': aspectRatio = 1.2; break; 
                default: aspectRatio = 3;
            }

            canvas.style.width = `${rect.width}px`;
            const displayHeight = rect.width * aspectRatio;
            canvas.style.height = `${displayHeight}px`;
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr; 
            canvas.height = displayHeight * dpr;
            ctx.scale(dpr, dpr); // DPR ìŠ¤ì¼€ì¼ë§ì„ ì—¬ê¸°ì— ì ìš©
        }


        // === initializeTextPositions ===
        // ê¸€ìë¥¼ ì²˜ìŒì— ì–´ë””ì— ë‘˜ì§€(ìœ„ìª½, ê°€ìš´ë°, ì•„ë˜ìª½) ì •í•´ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ë‚˜ì¤‘ì— ì§ì ‘ ëŒì–´ì„œ ì˜®ê¸¸ ìˆ˜ ìˆì§€ë§Œ ì²˜ìŒ ìœ„ì¹˜ë¥¼ ì¡ì•„ì¤˜ìš”.
        function initializeTextPositions() {
            const W = canvas.parentElement.getBoundingClientRect().width;
            const H = canvas.parentElement.getBoundingClientRect().height;
            const margin = W * (config.frameMargin / 100);
            const p = W * (config.imagePadding / 100); 

            let mainY, subY;
            
            // âœ¨ ìˆ˜ì •: í°íŠ¸ í¬ê¸° ì¶”ì •ì¹˜ ê³„ì‚° ì‹œ ë¶ˆí•„ìš”í•œ ìŠ¤ì¼€ì¼ íŒ©í„° ì œê±° (W, H, size ëª¨ë‘ CSS í”½ì…€ ë‹¨ìœ„)
            const mainTextHeightEst = config.mainText.size * 1.2; 
            const subTextHeightEst = config.subText.size * 1.2; 

            if (config.mainText.position === 'bottom') {
                mainY = H - margin - p - (mainTextHeightEst / 2);
                subY = margin + p + (subTextHeightEst / 2); 
            } else if (config.mainText.position === 'top') {
                mainY = margin + p + (mainTextHeightEst / 2);
                subY = H - margin - p - (subTextHeightEst / 2); 
            } else { // center
                mainY = H / 2 - subTextHeightEst;
                subY = H / 2 + mainTextHeightEst; 
            }
            
            // ìœ„ì¹˜ë¥¼ ë¹„ìœ¨(0.0 ~ 1.0)ë¡œ ì €ì¥
            config.mainText.x = 0.5;
            config.mainText.y = mainY / H; 
            config.subText.x = 0.5;
            config.subText.y = subY / H; 
            
            updateTextOverlay(); 
        }

        // --- í…ìŠ¤íŠ¸ ì˜¤ë²„ë ˆì´(ë“œë˜ê·¸ìš©) ì—…ë°ì´íŠ¸ ---
        function updateTextOverlay() {
            const { mainText, subText } = config;
            const { width: dW, height: dH } = canvas.getBoundingClientRect();
            
            mainTextOverlay.textContent = mainText.content;
            mainTextOverlay.style.color = mainText.color;
            mainTextOverlay.style.fontFamily = mainText.font;
            mainTextOverlay.style.fontSize = `${mainText.size}px`;
            mainTextOverlay.style.fontWeight = 'bold';
            
            // NEW: Simulate stroke with text-shadow for overlay
            let shadow = 'none';
            if (mainText.strokeWidth > 0) {
                const sw = mainText.strokeWidth;
                const sc = mainText.strokeColor;
                // Multi-directional shadow to simulate stroke
                // For a good effect, we use four directions
                shadow = `${sc} ${sw}px 0, ${sc} ${-sw}px 0, ${sc} 0 ${sw}px, ${sc} 0 ${-sw}px`;
            }
            mainTextOverlay.style.textShadow = shadow;


            const mainTextWidth = mainTextOverlay.offsetWidth;
            const mainTextHeight = mainTextOverlay.offsetHeight;
            
            mainTextOverlay.style.left = `${(dW * mainText.x) - (mainTextWidth / 2)}px`;
            mainTextOverlay.style.top = `${(dH * mainText.y) - (mainTextHeight / 2)}px`;

            subTextOverlay.textContent = subText.content;
            subTextOverlay.style.color = subText.color;
            subTextOverlay.style.fontFamily = subText.font;
            subTextOverlay.style.fontSize = `${subText.size}px`;
            subTextOverlay.style.fontWeight = 'normal';
            
            const subTextWidth = subTextOverlay.offsetWidth;
            const subTextHeight = subTextOverlay.offsetHeight;
            
            subTextOverlay.style.left = `${(dW * subText.x) - (subTextWidth / 2)}px`;
            subTextOverlay.style.top = `${(dH * subText.y) - (subTextHeight / 2)}px`;
        }

        // === addTextDragListeners ===
        // ê¸€ì ìƒìë¥¼ ë§ˆìš°ìŠ¤ë‚˜ ì†ê°€ë½ìœ¼ë¡œ ì¡ê³  ëŒ ìˆ˜ ìˆê²Œ í•´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ëŒë©´ì„œ ìœ„ì¹˜ê°€ ë°”ë€Œë©´ ê·¸ ìœ„ì¹˜ë¥¼ ê¸°ì–µí•´ ë‘¬ìš”.
        function addTextDragListeners(element, key) {
            let isDragging = false;
            let startClientX, startClientY; 
            let startElementX, startElementY; 

            const startDrag = (e) => {
                e.preventDefault();
                isDragging = true;
                isDraggingText = true;
                element.classList.add('dragging');
                drawCanvas();
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                startClientX = clientX;
                startClientY = clientY;
                
                const parentRect = element.parentElement.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
                
                startElementX = elementRect.left - parentRect.left;
                startElementY = elementRect.top - parentRect.top;

                element.style.cursor = 'grabbing';
            };

            const moveDrag = (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const dx = clientX - startClientX; 
                const dy = clientY - startClientY;

                let newX = startElementX + dx;
                let newY = startElementY + dy;
                
                const parentRect = element.parentElement.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect(); 
                const elementWidth = elementRect.width;
                const elementHeight = elementRect.height;

                // âœ¨ ìˆ˜ì •: frameMarginì´ ì•„ë‹Œ ì‘ì€ ì—¬ë°±ìœ¼ë¡œ í”„ë ˆì„ ë‚´ì—ì„œ ììœ ë¡­ê²Œ ì´ë™
                const minMargin = 5; // í”„ë ˆì„ í…Œë‘ë¦¬ë¡œë¶€í„° 5px ì—¬ìœ 

                // --- ê²½ê³„ê°’ ì²˜ë¦¬ (í”„ë ˆì„ ë‚´ì—ì„œë§Œ ì´ë™ ê°€ëŠ¥) ---
                newX = Math.max(newX, minMargin); 
                newX = Math.min(newX, parentRect.width - elementWidth - minMargin);
                newY = Math.max(newY, minMargin);
                newY = Math.min(newY, parentRect.height - elementHeight - minMargin);
                
                element.style.left = `${newX}px`;
                element.style.top = `${newY}px`;
                
                // í…ìŠ¤íŠ¸ì˜ "ì¤‘ì•™" ë¹„ìœ¨ì„ ì €ì¥í•˜ì—¬ ìº”ë²„ìŠ¤ ë Œë”ë§ê³¼ ë™ê¸°í™”
                const centerX = newX + (elementWidth / 2);
                const centerY = newY + (elementHeight / 2);

                config[key].x = centerX / parentRect.width;
                config[key].y = centerY / parentRect.height;
            };

            const endDrag = () => {
                if (isDragging) {
                    isDragging = false;
                    isDraggingText = false;
                    element.classList.remove('dragging');
                    element.style.cursor = 'grab';
                    drawCanvas();
                }
            };
            
            element.addEventListener('mousedown', startDrag);
            element.addEventListener('touchstart', startDrag, { passive: false });

            document.addEventListener('mousemove', moveDrag);
            document.addEventListener('touchmove', moveDrag, { passive: false });

            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
        }

        // === handleFiles ===
        // "ì‚¬ì§„ ê³¨ë¼!" í•˜ë©´ ì„ íƒí•œ ì‚¬ì§„ë“¤ì„ ì½ì–´ì„œ ì•± ì•ˆì— ë„£ì–´ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ë°”ë¡œ ë¯¸ë¦¬ë³´ê¸°ì™€ í° íŒì— ë³´ì—¬ì¤˜ìš”.
        async function handleFiles(files) {
            const fileList = Array.from(files).slice(0, MAX_IMAGES - config.images.length);
            if (fileList.length === 0) {
                 if(config.images.length >= MAX_IMAGES) alert(`ìµœëŒ€ ${MAX_IMAGES}ì¥ê¹Œì§€ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
                 return;
            }
            showLoader(true);
            const currentTheme = themes[config.theme];
            for (const file of fileList) {
                try {
                    const img = await loadImage(file);
                    config.images.push({ 
                        id: Date.now() + Math.random(), 
                        image: img,
                        // ì¹´ë©”ë¼ì—ì„œ ì°ì€ ì‚¬ì§„ì˜ ê²½ìš° ì¢Œìš° ë°˜ì „ ê¸°ë³¸ ì ìš©
                        flipped: (file.name && file.name.includes('image') && document.getElementById('cameraUpload').files.length > 0) ? true : false,
                        rotation: 0,
                        filter: currentTheme.filter || null // í…Œë§ˆì— ë§ëŠ” í•„í„° ì ìš©
                    });
                } catch (error) { console.error("Image loading failed:", error); }
            }
            renderImagePreviews(); drawCanvas(); showLoader(false);
            document.getElementById('imageUpload').value = null;
            document.getElementById('cameraUpload').value = null;
        }

        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => { const img = new Image(); img.onload = () => resolve(img); img.onerror = reject; img.src = e.target.result; };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // === renderImagePreviews ===
        // ì•„ë˜ìª½ì— ì‘ì€ ì‚¬ì§„ ì¸ë„¤ì¼ë“¤ì„ ë³´ì—¬ì£¼ê³ , ìˆœì„œ ë°”ê¾¸ê¸°Â·ì¢Œìš° ë’¤ì§‘ê¸°Â·íšŒì „í•˜ê¸°Â·ì§€ìš°ê¸°ë¥¼ í•  ìˆ˜ ìˆê²Œ í•´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function renderImagePreviews() {
            const container = document.getElementById('imagePreviews');
            container.innerHTML = '';
            
            config.images.forEach((imgData, index) => {
                const div = document.createElement('div');
                div.className = 'preview-item relative group aspect-square transition-all duration-300';
                div.dataset.index = index;
                div.draggable = true;

                const img = document.createElement('img');
                img.src = imgData.image.src;
                img.className = 'w-full h-full object-cover rounded-lg shadow-md';
                let transform = `scaleX(${imgData.flipped ? -1 : 1}) rotate(${imgData.rotation}deg)`;
                img.style.transform = transform;
                // í•„í„° ìŠ¤íƒ€ì¼ ì ìš©
                if(imgData.filter === 'grayscale') img.style.filter = 'grayscale(100%)';
                else if(imgData.filter === 'sepia') img.style.filter = 'sepia(100%)';
                else img.style.filter = 'none';

                const btnContainer = document.createElement('div');
                btnContainer.className = 'absolute top-1 left-1 right-1 flex justify-between opacity-0 group-hover:opacity-100 transition-opacity z-10';

                const leftBtns = document.createElement('div');
                const flipBtn = document.createElement('button');
                flipBtn.innerHTML = 'â†”ï¸';
                flipBtn.className = `rounded-full w-7 h-7 flex items-center justify-center font-bold text-xs transition-all duration-200 ${imgData.flipped ? 'bg-gray-900 text-white' : 'bg-white text-gray-800'}`;
                flipBtn.title = 'ì¢Œìš° ë°˜ì „';
                flipBtn.onclick = () => flipImage(index);
                leftBtns.appendChild(flipBtn);
                
                const rotateBtn = document.createElement('button');
                rotateBtn.innerHTML = 'ğŸ”„';
                rotateBtn.className = 'bg-white text-gray-800 rounded-full w-7 h-7 ml-1 flex items-center justify-center font-bold text-xs';
                rotateBtn.title = '90ë„ íšŒì „';
                rotateBtn.onclick = () => rotateImage(index);
                leftBtns.appendChild(rotateBtn);

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '&times;';
                removeBtn.className = 'bg-red-500 text-white rounded-full w-7 h-7 flex items-center justify-center font-bold';
                removeBtn.onclick = () => removeImage(index);
                
                btnContainer.appendChild(leftBtns);
                btnContainer.appendChild(removeBtn);
                
                div.appendChild(img);
                div.appendChild(btnContainer);
                container.appendChild(div);
            });

            // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì¬ì •ë ¬ ë¡œì§ 
            document.querySelectorAll('.preview-item').forEach(item => {
                item.addEventListener('dragstart', (e) => { draggedItem = item; setTimeout(() => item.classList.add('dragging'), 0); });
                item.addEventListener('dragend', (e) => { draggedItem.classList.remove('dragging'); draggedItem = null; });
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const afterElement = getDragAfterElement(container, e.clientY);
                    if (afterElement == null) { container.appendChild(draggedItem); } 
                    else { container.insertBefore(draggedItem, afterElement); }
                });
            });
            container.addEventListener('drop', (e) => {
                e.preventDefault();
                const newOrder = [...container.querySelectorAll('.preview-item')].map(item => config.images[parseInt(item.dataset.index)]);
                config.images = newOrder;
                renderImagePreviews(); drawCanvas();
            });
            document.getElementById('fileStatus').textContent = `${config.images.length} / ${MAX_IMAGES}ì¥ ì—…ë¡œë“œë¨.`;
        }

        // === getDragAfterElement ===
        // ì‘ì€ ì‚¬ì§„ë“¤ì„ ë“œë˜ê·¸ë¡œ ìˆœì„œ ë°”ê¿€ ë•Œ "ì—¬ê¸°ì— ë„£ì!" ìœ„ì¹˜ë¥¼ ì •í™•íˆ ì°¾ì•„ì£¼ëŠ” ë„ìš°ë¯¸ í•¨ìˆ˜ì˜ˆìš”.
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.preview-item:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) { return { offset: offset, element: child }; } 
                else { return closest; }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function flipImage(index) { config.images[index].flipped = !config.images[index].flipped; renderImagePreviews(); drawCanvas(); }
        function rotateImage(index) { config.images[index].rotation = (config.images[index].rotation + 90) % 360; renderImagePreviews(); drawCanvas(); }
        function removeImage(index) { config.images.splice(index, 1); renderImagePreviews(); drawCanvas(); }
        
        // === drawRoundedRect ===
        // ëª¨ì„œë¦¬ë¥¼ ë™ê·¸ë—ê²Œ ë§Œë“œëŠ” ì‚¬ê°í˜•ì„ ê·¸ë ¤ì£¼ëŠ” ë„ìš°ë¯¸ í•¨ìˆ˜ì˜ˆìš”. ì‚¬ì§„ ëª¨ì„œë¦¬ë¥¼ ë‘¥ê¸€ê²Œ í•  ë•Œ ì¨ìš”.
        function drawRoundedRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        // === resizeCanvas ===
        // í™”ë©´ í¬ê¸°ê°€ ë°”ë€Œê±°ë‚˜ ë ˆì´ì•„ì›ƒì„ ë°”ê¿€ ë•Œ ì‚¬ì§„ ë„£ëŠ” í° íŒ(ìº”ë²„ìŠ¤)ì„ ë”± ë§ê²Œ í¬ê¸° ì¡°ì •í•´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function drawCanvas() {
            // resizeCanvasì—ì„œ ì´ë¯¸ dpr ìŠ¤ì¼€ì¼ë§ì„ ì„¤ì •í–ˆìœ¼ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” dprì„ ë‹¤ì‹œ ê³±í•  í•„ìš” ì—†ìŒ
            const { width: dW, height: dH } = canvas.getBoundingClientRect();

            // 1. ë°°ê²½ìƒ‰ ì±„ìš°ê¸°
            ctx.fillStyle = config.backgroundColor; 
            ctx.fillRect(0, 0, dW, dH);
            
            // 2. í”„ë ˆì„ ì˜ì—­ ê³„ì‚° ë° ê·¸ë¦¬ê¸°
            const margin = dW * (config.frameMargin / 100);
            const fx = margin, fy = margin, fw = dW - 2 * margin, fh = dH - 2 * margin;
            ctx.fillStyle = config.frameColor; 
            ctx.fillRect(fx, fy, fw, fh);
            
            // 3. ì‚¬ì§„ ìŠ¬ë¡¯ ê³„ì‚° ë° ê·¸ë¦¬ê¸°
            const p = fw * (config.imagePadding / 100); 
            
            if (config.layout === '1x4') {
                const photoW = fw - 2 * p; const photoH = (fh - 5 * p) / 4; 
                for (let i = 0; i < 4; i++) drawPhotoSlot(i, fx + p, fy + p + i * (photoH + p), photoW, photoH);
            } else if (config.layout === '2x2') {
                const photoW = (fw - 3 * p) / 2; const photoH = (fh - 3 * p) / 2;
                drawPhotoSlot(0, fx + p, fy + p, photoW, photoH); drawPhotoSlot(1, fx + 2 * p + photoW, fy + p, photoW, photoH);
                drawPhotoSlot(2, fx + p, fy + 2 * p + photoH, photoW, photoH); drawPhotoSlot(3, fx + 2 * p + photoW, fy + 2 * p + photoH, photoW, photoH);
            } else if (config.layout === '1+3') {
                const bigH = fh * 0.6 - p * 1.5; const smallH = fh * 0.4 - p * 1.5;
                drawPhotoSlot(0, fx + p, fy + p, fw - 2 * p, bigH);
                const smallW = (fw - 4 * p) / 3;
                for (let i = 0; i < 3; i++) drawPhotoSlot(i + 1, fx + p + i * (smallW + p), fy + bigH + 2 * p, smallW, smallH);
            } else if (config.layout === '2+3') { 
                const topH = fh * 0.45 - p * 1.5; const bottomH = fh * 0.55 - p * 1.5;
                const topW = (fw - 3 * p) / 2;
                const bottomW = (fw - 4 * p) / 3;
                drawPhotoSlot(0, fx + p, fy + p, topW, topH);
                drawPhotoSlot(1, fx + p * 2 + topW, fy + p, topW, topH);
                for (let i = 0; i < 3; i++) drawPhotoSlot(i + 2, fx + p + i * (bottomW + p), fy + p * 2 + topH, bottomW, bottomH);
            } else if (config.layout === '2x3') { 
                const photoW = (fw - 3 * p) / 2; const photoH = (fh - 4 * p) / 3;
                for (let i = 0; i < 6; i++) {
                    const row = Math.floor(i / 2); const col = i % 2;
                    drawPhotoSlot(i, fx + p + col * (photoW + p), fy + p + row * (photoH + p), photoW, photoH);
                }
            } else if (config.layout === '3x2') { 
                const photoW = (fw - 4 * p) / 3; const photoH = (fh - 3 * p) / 2;
                for (let i = 0; i < 6; i++) {
                    const row = Math.floor(i / 3); const col = i % 3;
                    drawPhotoSlot(i, fx + p + col * (photoW + p), fy + p + row * (photoH + p), photoW, photoH);
                }
            }
            
            // 4. í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° - ë“œë˜ê·¸ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ìº”ë²„ìŠ¤ì— ê·¸ë¦½ë‹ˆë‹¤.
            if (!isDraggingText) {
                drawTextOnCanvas(dW, dH);
            }
            
            requestAnimationFrame(updateTextOverlay);
        }
        
        // === drawPhotoSlot ===
        // í•œ ì¹¸ í•œ ì¹¸ ì‚¬ì§„ ë„£ëŠ” ê³³ì— ì‚¬ì§„ì„ ì˜ˆì˜ê²Œ(í•„í„°Â·ë’¤ì§‘ê¸°Â·íšŒì „Â·ëª¨ì„œë¦¬ ë‘¥ê¸€ê²Œ) ë„£ê±°ë‚˜, ì‚¬ì§„ ì—†ì„ ë•ŒëŠ” "+" í‘œì‹œ ë„£ì–´ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function drawPhotoSlot(i, x, y, w, h) {
            const r = config.imageCornerRadius; // NEW: Get radius
            if (i < config.images.length) {
                const {image: img, flipped, rotation, filter} = config.images[i];
                
                const imgRatio = img.width / img.height, slotRatio = w / h;
                let sx = 0, sy = 0, sWidth = img.width, sHeight = img.height;
                if (imgRatio > slotRatio) { sWidth = sHeight * slotRatio; sx = (img.width - sWidth) / 2; } 
                else { sHeight = sWidth / slotRatio; sy = (img.height - sHeight) / 2; }
                
                ctx.save();
                if (filter === 'grayscale') ctx.filter = 'grayscale(100%)';
                else if (filter === 'sepia') ctx.filter = 'sepia(100%)';
                else ctx.filter = 'none';

                // NEW: Clipping path for rounded corners
                drawRoundedRect(ctx, x, y, w, h, r); 
                ctx.clip(); // Apply the clip path

                ctx.translate(x + w / 2, y + h / 2);
                if (flipped) ctx.scale(-1, 1);
                ctx.rotate(rotation * Math.PI / 180);
                
                ctx.drawImage(img, sx, sy, sWidth, sHeight, -w / 2, -h / 2, w, h);
                ctx.restore();
            } else {
                ctx.fillStyle = '#e5e7eb'; 
                drawRoundedRect(ctx, x, y, w, h, r); // NEW: Use rounded rect for placeholder
                ctx.fill();
                
                ctx.fillStyle = '#9ca3af';
                ctx.font = '30px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(`+`, x + w / 2, y + h / 2);
            }
        }
        
        // === drawTextOnCanvas ===
        // í° íŒì— ë©”ì¸ ê¸€ìì™€ ì‘ì€ ê¸€ìë¥¼ ì •í™•í•œ ìœ„ì¹˜Â·ìƒ‰Â·í¬ê¸°Â·í…Œë‘ë¦¬ë¡œ ê·¸ë ¤ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function drawTextOnCanvas(W, H) {
            const { mainText, subText } = config;

            // ë©”ì¸ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            if (mainText.content) {
                const textX = W * mainText.x;
                const textY = H * mainText.y;
                
                ctx.font = `bold ${mainText.size}px "${mainText.font}"`;
                ctx.textAlign = 'center'; 
                ctx.textBaseline = 'middle'; 
                
                // NEW: Draw Stroke first if present
                if (mainText.strokeWidth > 0) {
                    ctx.strokeStyle = mainText.strokeColor;
                    // Stroke width is multiplied by 2 for better visibility/thickness
                    ctx.lineWidth = mainText.strokeWidth * 2; 
                    ctx.strokeText(mainText.content, textX, textY);
                }

                // Draw Fill
                ctx.fillStyle = mainText.color; 
                ctx.fillText(mainText.content, textX, textY);
            }

            // ë¶€ì œëª© í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            if (subText.content) {
                const subTextX = W * subText.x;
                const subTextY = H * subText.y;
                
                ctx.fillStyle = subText.color; 
                ctx.font = `normal ${subText.size}px "${subText.font}"`;
                ctx.textAlign = 'center'; 
                ctx.textBaseline = 'middle'; 
                ctx.fillText(subText.content, subTextX, subTextY);
            }
        }


        // === downloadImage ===
        // ì»´í“¨í„°ì—ì„œ "ì €ì¥!" ëˆ„ë¥´ë©´ ì˜ˆì˜ê³  í° ì‚¬ì´ì¦ˆì˜ ì™„ì„± ì‚¬ì§„ì„ íŒŒì¼ë¡œ ë‚´ë ¤ë°›ê²Œ í•´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function downloadImage(format) {
            if (config.images.length === 0) { alert("ì‚¬ì§„ì„ ë¨¼ì € 1ì¥ ì´ìƒ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!"); return; }
            // DPRì„ ê³ ë ¤í•œ ì›ë³¸ í•´ìƒë„ë¡œ ì €ì¥
            const tempCanvas = document.createElement('canvas');
            const displayW = canvas.parentElement.getBoundingClientRect().width;
            let aspectRatio;
            switch(config.layout) {
                case '1x4': aspectRatio = 3; break;
                case '2x2': aspectRatio = 1.5; break;
                case '1+3': aspectRatio = 2; break;
                case '2+3': aspectRatio = 1.8; break;
                case '2x3': aspectRatio = 2.2; break;
                case '3x2': aspectRatio = 1.2; break;
                default: aspectRatio = 3;
            }
            const displayH = displayW * aspectRatio;

            // ê³ í™”ì§ˆ ì¶œë ¥ì„ ìœ„í•´ ìµœì†Œ 1200px ë„ˆë¹„ë¡œ ì„¤ì •
            const renderW = 1200; 
            const renderH = renderW * aspectRatio;
            
            tempCanvas.width = renderW;
            tempCanvas.height = renderH;
            const tempCtx = tempCanvas.getContext('2d');
            
            // ì„ì‹œ ì»¨í…ìŠ¤íŠ¸ì— ìƒˆë¡œìš´ ìŠ¤ì¼€ì¼ ì ìš© (ë””ìŠ¤í”Œë ˆì´ í¬ê¸° -> ê³ í™”ì§ˆ í¬ê¸°)
            const scaleX = renderW / displayW;
            const scaleY = renderH / displayH;
            tempCtx.scale(scaleX, scaleY);
            
            // ì„¤ì •ê°’ì„ ì„ì‹œ ìº”ë²„ìŠ¤ì— ë§ê²Œ ì¡°ì •í•˜ì—¬ ê·¸ë¦¬ê¸° (ë¡œì§ ì¬ì‚¬ìš©)
            const oldConfig = JSON.parse(JSON.stringify(config));
            const oldImages = config.images;

        // === downloadBlobAsFile ===
        // ì‚¬ì§„ ë°ì´í„°ë¥¼ ì‹¤ì œ íŒŒì¼ë¡œ ë‚´ë ¤ë°›ê²Œ í•´ ì£¼ëŠ” ì‘ì€ ë„ìš°ë¯¸ í•¨ìˆ˜ì˜ˆìš”.
        // Blobì„ íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œí•˜ëŠ” í—¬í¼ í•¨ìˆ˜
        // Web Share APIë¥¼ ì§€ì›í•˜ì§€ ì•Šê±°ë‚˜ ì‹¤íŒ¨í–ˆì„ ë•Œ ëŒ€ì²´(Fallback)ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.
        function downloadBlobAsFile(blob, filename) {
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        // === saveToGallery ===
        // í•¸ë“œí°ì—ì„œ "ì €ì¥!" ëˆ„ë¥´ë©´ ê°¤ëŸ¬ë¦¬ì— ë°”ë¡œ ì €ì¥í•˜ê±°ë‚˜ ê³µìœ í•  ìˆ˜ ìˆê²Œ ë„ì™€ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ì•ˆ ë˜ë©´ ê·¸ëƒ¥ ë‚´ë ¤ë°›ê²Œ í•´ì¤˜ìš”.
        async function saveToGallery(format) {
            if (config.images.length === 0) { 
                alert("ì‚¬ì§„ì„ ë¨¼ì € 1ì¥ ì´ìƒ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!"); 
                return; 
            }

            // ê³ í™”ì§ˆ ë Œë”ë§ì„ ìœ„í•œ ì„ì‹œ ìº”ë²„ìŠ¤ ìƒì„± ë° ì„¤ì • ë¡œì§ (ê¸°ì¡´ downloadImageì™€ ë™ì¼)
            const tempCanvas = document.createElement('canvas');
            const displayW = canvas.parentElement.getBoundingClientRect().width;
            let aspectRatio;
            switch(config.layout) {
                case '1x4': aspectRatio = 3; break;
                case '2x2': aspectRatio = 1.5; break;
                case '1+3': aspectRatio = 2; break;
                case '2+3': aspectRatio = 1.8; break;
                case '2x3': aspectRatio = 2.2; break;
                case '3x2': aspectRatio = 1.2; break;
                default: aspectRatio = 3;
            }
            const displayH = displayW * aspectRatio;
            const renderW = 1200; 
            const renderH = renderW * aspectRatio;
            
            tempCanvas.width = renderW;
            tempCanvas.height = renderH;
            const tempCtx = tempCanvas.getContext('2d');
            
            const scaleX = renderW / displayW;
            const scaleY = renderH / displayH;
            tempCtx.scale(scaleX, scaleY);
            
            const oldConfig = JSON.parse(JSON.stringify(config));
            const oldImages = config.images;
            
            drawCanvasOnContext(tempCtx, renderW / scaleX, renderH / scaleY, oldConfig, oldImages);

            showLoader(true);
            try {
                // Canvasë¥¼ Blob (ì´ì§„ ë°ì´í„°)ìœ¼ë¡œ ë³€í™˜
                tempCanvas.toBlob(async (blob) => {
                    try {
                        const mimeType = format === 'jpeg' ? 'image/jpeg' : 'image/png';
                        // Blobì„ Web Share APIê°€ ìš”êµ¬í•˜ëŠ” File ê°ì²´ë¡œ ë³€í™˜
                        const file = new File([blob], `photobooth_${Date.now()}.${format}`, { type: mimeType });

                        // Web Share API ì§€ì› ì—¬ë¶€ ë° íŒŒì¼ ê³µìœ  ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
                        if (navigator.share && navigator.canShare({ files: [file] })) {
                            await navigator.share({
                                files: [file],
                                title: 'í”„ë ˆì„ ë‹¤ì´ì–´ë¦¬ ê²°ê³¼ë¬¼',
                                text: 'ìº”ë²„ìŠ¤ ê²°ê³¼ë¬¼ì„ ê°¤ëŸ¬ë¦¬ì— ì €ì¥í•˜ê±°ë‚˜ ê³µìœ í•´ë³´ì„¸ìš”.'
                            });
                            alert('âœ… ê³µìœ  ë©”ë‰´ê°€ ì—´ë ¸ìŠµë‹ˆë‹¤. ê°¤ëŸ¬ë¦¬ì— ì €ì¥í•˜ê±°ë‚˜ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                        } else {
                            // Fallback: ì¼ë°˜ ë‹¤ìš´ë¡œë“œ (Web Share API ë¯¸ì§€ì› ì‹œ)
                            downloadBlobAsFile(blob, `photobooth_${Date.now()}.${format}`);
                            alert('âœ… Web Share APIê°€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.');
                        }
                    } catch (error) {
                        console.error('Share error:', error);
                        // ì—ëŸ¬ ë°œìƒ ì‹œ ë‹¤ìš´ë¡œë“œ ì‹œë„
                        downloadBlobAsFile(blob, `photobooth_${Date.now()}.${format}`);
                        alert('ì €ì¥ ê¸°ëŠ¥ ì‹¤í–‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.');
                    }
                }, format === 'jpeg' ? 'image/jpeg' : 'image/png', format === 'jpeg' ? 0.95 : 1.0);
            } catch (e) { 
                alert("ì´ë¯¸ì§€ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."); 
                console.error(e); 
            }
            showLoader(false); 
        }
            
            // ê¸°ì¡´ drawCanvas ë¡œì§ì„ ì„ì‹œ ìº”ë²„ìŠ¤ì— ë§ê²Œ ì‹¤í–‰
            drawCanvasOnContext(tempCtx, renderW / scaleX, renderH / scaleY, oldConfig, oldImages);
            const mimeType = format === 'jpeg' ? 'image/jpeg' : 'image/png'; 
            const quality = format === 'jpeg' ? 0.95 : 1.0;
            showLoader(true); 
            try {
                const link = document.createElement('a');
                link.href = tempCanvas.toDataURL(mimeType, quality);
                link.download = `photobooth_pro_${Date.now()}.${format}`;
                link.click();
            } catch (e) { alert("ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (íŒŒì¼ ìš©ëŸ‰ ë˜ëŠ” ê¶Œí•œ ë¬¸ì œ)"); console.error(e); }
            showLoader(false); 
        }

        async function saveToGallery(format) {
    if (config.images.length === 0) { 
        alert("ì‚¬ì§„ì„ ë¨¼ì € 1ì¥ ì´ìƒ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!"); 
        return; 
    }

    // ê¸°ì¡´ downloadImageì™€ ë™ì¼í•œ ë¡œì§ìœ¼ë¡œ ìº”ë²„ìŠ¤ ìƒì„±
    const tempCanvas = document.createElement('canvas');
    const displayW = canvas.parentElement.getBoundingClientRect().width;
    let aspectRatio;
    switch(config.layout) {
        case '1x4': aspectRatio = 3; break;
        case '2x2': aspectRatio = 1.5; break;
        case '1+3': aspectRatio = 2; break;
        case '2+3': aspectRatio = 1.8; break;
        case '2x3': aspectRatio = 2.2; break;
        case '3x2': aspectRatio = 1.2; break;
        default: aspectRatio = 3;
    }
    const displayH = displayW * aspectRatio;
    const renderW = 1200; 
    const renderH = renderW * aspectRatio;
    
    tempCanvas.width = renderW;
    tempCanvas.height = renderH;
    const tempCtx = tempCanvas.getContext('2d');
    
    const scaleX = renderW / displayW;
    const scaleY = renderH / displayH;
    tempCtx.scale(scaleX, scaleY);
    
    const oldConfig = JSON.parse(JSON.stringify(config));
    const oldImages = config.images;
    
    drawCanvasOnContext(tempCtx, renderW / scaleX, renderH / scaleY, oldConfig, oldImages);

    showLoader(true);
    try {
        // Canvasë¥¼ Blobìœ¼ë¡œ ë³€í™˜
        tempCanvas.toBlob(async (blob) => {
            try {
                // Canvas APIë¥¼ ì‚¬ìš©í•œ ê°¤ëŸ¬ë¦¬ ì €ì¥ ì‹œë„
                if (navigator.share && navigator.canShare({ files: [new File([blob], `photo.${format}`, { type: format === 'jpeg' ? 'image/jpeg' : 'image/png' })] })) {
                    await navigator.share({
                        files: [new File([blob], `photobooth_${Date.now()}.${format}`, { type: format === 'jpeg' ? 'image/jpeg' : 'image/png' })]
                    });
                    alert('âœ… ê°¤ëŸ¬ë¦¬ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
                } else {
                    // Fallback: ì¼ë°˜ ë‹¤ìš´ë¡œë“œ
                    downloadBlobAsFile(blob, `photobooth_${Date.now()}.${format}`);
                    alert('âœ… íŒŒì¼ì´ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!');
                }
            } catch (error) {
                console.error('Share error:', error);
                downloadBlobAsFile(blob, `photobooth_${Date.now()}.${format}`);
            }
        }, format === 'jpeg' ? 'image/jpeg' : 'image/png', format === 'jpeg' ? 0.95 : 1.0);
    } catch (e) { 
        alert("ì´ë¯¸ì§€ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."); 
        console.error(e); 
    }
    showLoader(false); 
}

// Blobì„ íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œí•˜ëŠ” í—¬í¼ í•¨ìˆ˜
function downloadBlobAsFile(blob, filename) {
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.href = url;
    link.download = filename;
    link.click();
    URL.revokeObjectURL(url);
}
        // === drawCanvasOnContext ===
        // ì•„ì£¼ í° ì‚¬ì´ì¦ˆë¡œ ì €ì¥í•  ë•Œ ì“°ëŠ” ì„ì‹œ íŒì— ë˜‘ê°™ì´ ì˜ˆì˜ê²Œ ê·¸ë ¤ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        // ê³ í™”ì§ˆ ì¶œë ¥ì„ ìœ„í•œ ë³´ì¡° í•¨ìˆ˜: íŠ¹ì • ì»¨í…ìŠ¤íŠ¸ì— ê·¸ë¦¬ê¸°
        // dW, dHëŠ” ìº”ë²„ìŠ¤ì˜ ë…¼ë¦¬ì  í¬ê¸°(displayW, displayH)ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
        function drawCanvasOnContext(targetCtx, dW, dH, tempConfig, tempImages) {
            targetCtx.fillStyle = tempConfig.backgroundColor; 
            targetCtx.fillRect(0, 0, dW, dH);
            
            const margin = dW * (tempConfig.frameMargin / 100);
            const fx = margin, fy = margin, fw = dW - 2 * margin, fh = dH - 2 * margin;
            targetCtx.fillStyle = tempConfig.frameColor; 
            targetCtx.fillRect(fx, fy, fw, fh);
            
            const p = fw * (tempConfig.imagePadding / 100); 
            
            const drawSlotOnContext = (i, x, y, w, h) => {
                const r = tempConfig.imageCornerRadius; // NEW: Get radius
                if (i < tempImages.length) {
                    const {image: img, flipped, rotation, filter} = tempImages[i];
                    
                    const imgRatio = img.width / img.height, slotRatio = w / h;
                    let sx = 0, sy = 0, sWidth = img.width, sHeight = img.height;
                    if (imgRatio > slotRatio) { sWidth = sHeight * slotRatio; sx = (img.width - sWidth) / 2; } 
                    else { sHeight = sWidth / slotRatio; sy = (img.height - sHeight) / 2; }
                    
                    targetCtx.save();
                    if (filter === 'grayscale') targetCtx.filter = 'grayscale(100%)';
                    else if (filter === 'sepia') targetCtx.filter = 'sepia(100%)';
                    else targetCtx.filter = 'none';

                    // NEW: Clipping path for rounded corners
                    drawRoundedRect(targetCtx, x, y, w, h, r);
                    targetCtx.clip(); // Apply the clip path

                    targetCtx.translate(x + w / 2, y + h / 2);
                    if (flipped) targetCtx.scale(-1, 1);
                    targetCtx.rotate(rotation * Math.PI / 180);
                    
                    targetCtx.drawImage(img, sx, sy, sWidth, sHeight, -w / 2, -h / 2, w, h);
                    targetCtx.restore();
                } else {
                    targetCtx.fillStyle = '#e5e7eb'; 
                    drawRoundedRect(targetCtx, x, y, w, h, r); // NEW: Use rounded rect for placeholder
                    targetCtx.fill();
                    
                    targetCtx.fillStyle = '#9ca3af';
                    targetCtx.font = '30px Inter'; targetCtx.textAlign = 'center'; targetCtx.textBaseline = 'middle';
                    targetCtx.fillText(`+`, x + w / 2, y + h / 2);
                }
            };

            // ë ˆì´ì•„ì›ƒë³„ ìŠ¬ë¡¯ ê·¸ë¦¬ê¸° ë¡œì§ (ê¸°ì¡´ ë¡œì§ ì¬ì‚¬ìš©)
            if (tempConfig.layout === '1x4') {
                const photoW = fw - 2 * p; const photoH = (fh - 5 * p) / 4; 
                for (let i = 0; i < 4; i++) drawSlotOnContext(i, fx + p, fy + p + i * (photoH + p), photoW, photoH);
            } else if (tempConfig.layout === '2x2') {
                const photoW = (fw - 3 * p) / 2; const photoH = (fh - 3 * p) / 2;
                drawSlotOnContext(0, fx + p, fy + p, photoW, photoH); drawSlotOnContext(1, fx + 2 * p + photoW, fy + p, photoW, photoH);
                drawSlotOnContext(2, fx + p, fy + 2 * p + photoH, photoW, photoH); drawSlotOnContext(3, fx + 2 * p + photoW, fy + 2 * p + photoH, photoW, photoH);
            } else if (tempConfig.layout === '1+3') {
                const bigH = fh * 0.6 - p * 1.5; const smallH = fh * 0.4 - p * 1.5;
                drawSlotOnContext(0, fx + p, fy + p, fw - 2 * p, bigH);
                const smallW = (fw - 4 * p) / 3;
                for (let i = 0; i < 3; i++) drawSlotOnContext(i + 1, fx + p + i * (smallW + p), fy + bigH + 2 * p, smallW, smallH);
            } else if (tempConfig.layout === '2+3') { 
                const topH = fh * 0.45 - p * 1.5; const bottomH = fh * 0.55 - p * 1.5;
                const topW = (fw - 3 * p) / 2;
                const bottomW = (fw - 4 * p) / 3;
                drawSlotOnContext(0, fx + p, fy + p, topW, topH);
                drawSlotOnContext(1, fx + p * 2 + topW, fy + p, topW, topH);
                for (let i = 0; i < 3; i++) drawSlotOnContext(i + 2, fx + p + i * (bottomW + p), fy + p * 2 + topH, bottomW, bottomH);
            } else if (tempConfig.layout === '2x3') { 
                const photoW = (fw - 3 * p) / 2; const photoH = (fh - 4 * p) / 3;
                for (let i = 0; i < 6; i++) {
                    const row = Math.floor(i / 2); const col = i % 2;
                    drawSlotOnContext(i, fx + p + col * (photoW + p), fy + p + row * (photoH + p), photoW, photoH);
                }
            } else if (tempConfig.layout === '3x2') { 
                const photoW = (fw - 4 * p) / 3; const photoH = (fh - 3 * p) / 2;
                for (let i = 0; i < 6; i++) {
                    const row = Math.floor(i / 3); const col = i % 3;
                    drawSlotOnContext(i, fx + p + col * (photoW + p), fy + p + row * (photoH + p), photoW, photoH);
                }
            }
            
            // í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° (í°íŠ¸ í¬ê¸° ì´ë¯¸ ìŠ¤ì¼€ì¼ë§ë¨)
            if (tempConfig.mainText.content) {
                const textX = dW * tempConfig.mainText.x;
                const textY = dH * tempConfig.mainText.y;
                
                targetCtx.font = `bold ${tempConfig.mainText.size}px "${tempConfig.mainText.font}"`;
                targetCtx.textAlign = 'center'; 
                targetCtx.textBaseline = 'middle'; 

                 // NEW: Draw Stroke first if present (High-res)
                if (tempConfig.mainText.strokeWidth > 0) {
                    targetCtx.strokeStyle = tempConfig.mainText.strokeColor;
                    targetCtx.lineWidth = tempConfig.mainText.strokeWidth * 2; 
                    targetCtx.strokeText(tempConfig.mainText.content, textX, textY);
                }
                
                targetCtx.fillStyle = tempConfig.mainText.color; 
                targetCtx.fillText(tempConfig.mainText.content, textX, textY);
            }
            if (tempConfig.subText.content) {
                const subTextX = dW * tempConfig.subText.x;
                const subTextY = dH * tempConfig.subText.y;
                
                targetCtx.fillStyle = tempConfig.subText.color; 
                targetCtx.font = `normal ${tempConfig.subText.size}px "${tempConfig.subText.font}"`;
                targetCtx.textAlign = 'center'; 
                targetCtx.textBaseline = 'middle'; 
                targetCtx.fillText(tempConfig.subText.content, subTextX, subTextY);
            }

        }
        
        // === showLoader ===
        // ì‚¬ì§„ ì˜¬ë¦¬ê±°ë‚˜ ì €ì¥í•  ë•Œ "ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”~" ëŒì•„ê°€ëŠ” ë™ê·¸ë¼ë¯¸ë¥¼ ë³´ì—¬ì£¼ê±°ë‚˜ ìˆ¨ê¸°ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function showLoader(show) { 
            document.getElementById('loader').classList.toggle('hidden', !show);
            document.getElementById('loader').classList.toggle('flex', show);
        }
        
        window.addEventListener('resize', () => {
             resizeCanvas(); 
             updateTextOverlay(); 
             drawCanvas(); 
        });
    </script>
</body>
</html>