<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Frame Diary</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Caveat&family=Inter:wght@400;600;800&family=Lobster&family=Nanum+Pen+Script&family=Do+Hyeon&family=Gothic+A1&family=Permanent+Marker&family=Jua&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html, body { 
            overscroll-behavior-y: contain; 
            height: 100%;
        }
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #f3f4f6; 
            min-height: 100vh;
        }
        body {
            min-height: 100dvh; 
        }
        
        #canvasContainer { width: 100%; max-width: 420px; margin: 0 auto; position: relative; } 
        #photoCanvas {
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15); border: 1px solid #e5e7eb;
            display: block; width: 100%; height: auto; border-radius: 1rem;
        }
        
        #mainTextOverlay, #subTextOverlay {
            position: absolute; text-align: center; cursor: grab; user-select: none;
            z-index: 50; padding: 5px 10px; border-radius: 5px;
            transition: all 0.1s ease-out; 
            top: 0;
            left: 0;
            white-space: nowrap;
            opacity: 0;
            background-color: transparent;
            border: 1px dashed transparent;
        }
        
        .text-overlay.dragging {
            opacity: 1 !important;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px dashed #374151;
        }

        /* ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ ìŠ¤íƒ€ì¼ */
        .preview-item.dragging {
            opacity: 0.4;
            border: 2px solid #3b82f6;
        }
        /* ëª¨ë°”ì¼ì—ì„œ ë¡±í”„ë ˆìŠ¤ ì‹œ ì„ íƒë˜ëŠ” ê²ƒ ë°©ì§€ */
        .preview-item {
            user-select: none;
            -webkit-user-drag: none;
            touch-action: none; /* ëª¨ë°”ì¼ ë“œë˜ê·¸ë¥¼ ìœ„í•´ í•„ìš” */
        }

        .slot-overlay {
            position: absolute;
            cursor: grab;
            border-radius: 8px;
        }

        .slot-overlay.dragging {
            outline: 3px solid #6366f1;
            cursor: grabbing;
        }
        
        .tab-btn.active { border-color: #374151; color: #374151; font-weight: 700; }
        .control-btn {
            transition: all 0.2s ease-in-out; border: 1px solid #e5e7eb;
            padding: 1rem; min-width: 100px; text-align: center;
        }
        .control-btn.active {
            transform: scale(1.0); box-shadow: 0 0 0 3px rgba(55, 65, 81, 0.7);
            border-color: #374151; z-index: 10;
        }
        #textPositionButtons .control-btn.active { box-shadow: 0 0 0 2px rgba(55, 65, 81, 0.7); }
        #loader { backdrop-filter: blur(4px); }
        h1, h2, h3 { word-break: keep-all; }
        #dropZone.drag-over { border-color: #3b82f6; background-color: #eff6ff; }
        .preview-item.dragging { opacity: 0.5; transform: scale(0.95); }
        
        @media (max-width: 640px) {
            .control-btn {
                padding: 0.75rem;
                min-width: 80px; 
            }
        }

        @media (hover: hover) and (pointer: fine) {
            .text-overlay:hover:not(.dragging) { 
                background-color: rgba(255, 255, 255, 0.2); 
                border: 1px dashed rgba(55, 65, 81, 0.5); 
                opacity: 1; 
            }
        }
    </style>
</head>
<body class="min-h-screen">

    <div class="w-full max-w-7xl mx-auto bg-white lg:rounded-3xl lg:shadow-2xl lg:my-8 overflow-hidden">
        
        <header class="text-center py-6 border-b border-gray-100 lg:hidden">
            <h1 class="text-3xl font-black text-gray-900">Frame Diary</h1>
            <p class="text-gray-400 text-sm">ë‚˜ë§Œì˜ ì¶”ì–µì„ ë‹´ì€ í¬í† ë¶</p>
        </header>
        
        <main class="flex flex-col lg:flex-row lg:gap-12 lg:p-10">
            
            <div class="w-full lg:w-2/5 p-4 lg:p-0 lg:sticky lg:top-10 self-start">
                <header class="hidden lg:block mb-8 mt-4">
                    <h1 class="text-5xl font-extrabold text-gray-900 tracking-tighter">Frame Diary</h1>
                    <p class="text-xl text-gray-500 mt-1">ì‚¬ì§„ìœ¼ë¡œ íŠ¹ë³„í•œ ìˆœê°„ì„ ë‹´ë‹¤</p>
                </header>
                <div id="canvasContainer">
                    <canvas id="photoCanvas"></canvas>

                    <!-- ğŸ“¸ ì‚¬ì§„ ìŠ¬ë¡¯ ë“œë˜ê·¸ìš© ì˜¤ë²„ë ˆì´ -->
                    <div id="slotOverlayContainer"
                        style="position:absolute; inset:0; z-index:10;">
                    </div>

                    <!-- ê¸°ì¡´ í…ìŠ¤íŠ¸ ì˜¤ë²„ë ˆì´ -->
                    <div id="mainTextOverlay" class="text-overlay"></div>
                    <div id="subTextOverlay" class="text-overlay"></div>
                </div>
            </div>

            <div class="w-full lg:w-3/5">
                <nav class="flex border-b border-gray-200">
                    <button class="tab-btn active flex-1 p-4 font-medium border-b-4 border-transparent text-gray-500 flex items-center justify-center gap-2" data-tab="tab-photo">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 15H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" /></svg>
                        ì‚¬ì§„ ì¶”ê°€
                    </button>
                    <button class="tab-btn flex-1 p-4 font-medium border-b-4 border-transparent text-gray-500 flex items-center justify-center gap-2" data-tab="tab-design">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" /></svg>
                        ë ˆì´ì•„ì›ƒ & ìŠ¤íƒ€ì¼
                    </button>
                    <button class="tab-btn flex-1 p-4 font-medium border-b-4 border-transparent text-gray-500 flex items-center justify-center gap-2" data-tab="tab-text">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H4a1 1 0 110-2V4zm3 1h2v1H7V5zm0 2h2v1H7V7z" clip-rule="evenodd" /></svg>
                        í…ìŠ¤íŠ¸ ê¾¸ë¯¸ê¸°
                    </button>
                     <button class="tab-btn flex-1 p-4 font-medium border-b-4 border-transparent text-gray-500 flex items-center justify-center gap-2" data-tab="tab-save">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                        ì €ì¥í•˜ê¸°
                    </button>
                </nav>

                <div class="p-6 space-y-8">
                    <div id="tab-photo" class="tab-content space-y-4">
                        <div id="dropZone" class="w-full p-6 border-2 border-dashed border-gray-300 rounded-2xl text-center cursor-pointer hover:border-blue-500 hover:bg-gray-50 transition-colors">
                            <p class="font-bold text-gray-600">ğŸ‘‡ ì‚¬ì§„ì„ ì—¬ê¸°ì— ëŒì–´ì„œ ë†“ìœ¼ì„¸ìš”</p>
                            <p class="text-sm text-gray-400 mt-1">ë˜ëŠ” ì•„ë˜ ë²„íŠ¼ìœ¼ë¡œ ì„ íƒí•´ì£¼ì„¸ìš”</p>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <label for="imageUpload" class="w-full bg-gray-900 text-white p-4 rounded-2xl font-bold text-center cursor-pointer hover:bg-gray-800 transition-colors shadow-lg transform hover:scale-[1.01]">ğŸ“± íœ´ëŒ€í°ì—ì„œ ì„ íƒ</label>
                            <label for="cameraUpload" class="w-full bg-gray-700 text-white p-4 rounded-2xl font-bold text-center cursor-pointer hover:bg-gray-600 transition-colors shadow-lg transform hover:scale-[1.01]">ğŸ“¸ ì§€ê¸ˆ ë°”ë¡œ ì´¬ì˜</label>
                            <input type="file" id="imageUpload" multiple accept="image/*" class="hidden">
                            <input type="file" id="cameraUpload" accept="image/*" capture="user" class="hidden">
                        </div>
                        <div id="imagePreviewsContainer" class="space-y-4">
                            <p id="fileStatus" class="text-sm text-gray-500 h-5"></p> 
                            <div id="imagePreviews" class="grid grid-cols-3 sm:grid-cols-6 gap-4"></div>
                        </div>
                    </div>

                    <div id="tab-design" class="tab-content hidden space-y-6">
                        <div>
                           <h3 class="font-bold text-lg mb-2 text-gray-800">ğŸ“ ì‚¬ì§„ ë°°ì¹˜ ë°©ì‹</h3>
                           <div id="layoutButtons" class="grid grid-cols-3 gap-4">
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md active" data-layout="1x4">ì„¸ë¡œ<br/>4ì¥</button>
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md" data-layout="2x2">ì •ì‚¬ê°<br/>4ì¥</button>
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md" data-layout="1+3">í¼+ì‘ìŒ<br/>4ì¥</button>
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md" data-layout="2+3">í˜¼í•©<br/>5ì¥</button>
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md" data-layout="2x3">ì„¸ë¡œ<br/>6ì¥</button>
                                <button class="control-btn p-3 rounded-xl shadow-sm border font-semibold bg-white flex flex-col items-center justify-center text-sm hover:shadow-md" data-layout="3x2">ê°€ë¡œ<br/>6ì¥</button>
                            </div>
                        </div>
                         <div>
                            <h3 class="font-bold text-lg mb-2 text-gray-800">ğŸ¨ í…Œë§ˆ í”„ë¦¬ì…‹ (ì›í´ë¦­ ìŠ¤íƒ€ì¼)</h3>
                            <div id="themeButtons" class="grid grid-cols-3 sm:grid-cols-4 gap-4"></div>
                        </div>
                        <div>
                            <h3 class="font-bold text-lg mb-2 text-gray-800">âš™ï¸ ìƒì„¸ ì˜µì…˜</h3>
                            <div class="space-y-4">
                                <div>
                                    <label for="frameMarginSlider" class="font-semibold text-gray-600">ë°”ê¹¥ìª½ ì—¬ë°±: <span id="frameMarginValue">5</span>%</label>
                                    <input type="range" id="frameMarginSlider" min="0" max="20" value="5" class="w-full mt-2 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                                </div>
                                 <div>
                                    <label for="imagePaddingSlider" class="font-semibold text-gray-600">ì‚¬ì§„ ì‚¬ì´ ê°„ê²©: <span id="imagePaddingValue">5</span>%</label>
                                    <input type="range" id="imagePaddingSlider" min="0" max="20" value="5" class="w-full mt-2 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                                </div>
                                <div>
                                    <label for="imageRadiusSlider" class="font-semibold text-gray-600">ì‚¬ì§„ ëª¨ì„œë¦¬ ê³¡ì„ : <span id="imageRadiusValue">0</span>px</label>
                                    <input type="range" id="imageRadiusSlider" min="0" max="50" value="0" class="w-full mt-2 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                                </div>
                            </div>
                        </div>
                        <div>
                           <h3 class="font-bold text-lg mb-2 text-gray-800">ğŸŒˆ ìƒ‰ìƒ ì¡°ì •</h3>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="backgroundColorPicker" class="font-semibold text-gray-600 text-sm">ë°°ê²½ ìƒ‰</label>
                                    <input type="color" id="backgroundColorPicker" class="w-full h-10 p-1 mt-1 border rounded-md cursor-pointer hover:shadow-md">
                                </div>
                                <div>
                                    <label for="frameColorPicker" class="font-semibold text-gray-600 text-sm">í…Œë‘ë¦¬ ìƒ‰</label>
                                    <input type="color" id="frameColorPicker" class="w-full h-10 p-1 mt-1 border rounded-md cursor-pointer hover:shadow-md">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="tab-text" class="tab-content hidden space-y-6">
                         <h3 class="font-bold text-lg mb-4 text-gray-800">âœï¸ ì œëª©ê³¼ ì„¤ëª… ê¸€ê·€</h3>
                         <p class="text-sm text-blue-600 font-medium bg-blue-50 p-3 rounded-lg border border-blue-100">
                             ğŸ’¡ ìº”ë²„ìŠ¤ì—ì„œ ê¸€ê·€ë¥¼ ëˆŒëŸ¬ ë“œë˜ê·¸í•˜ë©´ ì›í•˜ëŠ” ìœ„ì¹˜ë¡œ ììœ ë¡­ê²Œ ì˜®ê¸¸ ìˆ˜ ìˆì–´ìš”.
                         </p>

                        <input type="text" id="customTextInput" placeholder="ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: SUMMER MEMORIES)" value="LIFE 4 CUTS" class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-gray-300 focus:border-gray-500 transition-shadow">
                        <input type="text" id="subTextInput" placeholder="ë‚ ì§œë‚˜ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: 2024ë…„ 8ì›”)" class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-gray-300 focus:border-gray-500 transition-shadow">
                        
                        <div class="space-y-3">
                            <h4 class="font-semibold text-gray-600">ì œëª©ì´ ì²˜ìŒ ë‚˜íƒ€ë‚  ìœ„ì¹˜ (í´ë¦­í•´ì„œ ë“œë˜ê·¸ë¡œ ì´ë™ ê°€ëŠ¥)</h4>
                            <div id="textPositionButtons" class="flex gap-2 sm:gap-4">
                                <button class="control-btn p-2 rounded-xl shadow-sm font-semibold text-sm w-1/3" data-position="top">ìœ„ìª½</button>
                                <button class="control-btn p-2 rounded-xl shadow-sm font-semibold text-sm w-1/3" data-position="center">ì¤‘ì•™</button>
                                <button class="control-btn p-2 rounded-xl shadow-sm font-semibold text-sm w-1/3 active" data-position="bottom">ì•„ë˜ìª½</button>
                            </div>
                        </div>
                        
                        <div class="p-4 border rounded-xl space-y-4 bg-gray-50">
                            <h4 class="font-bold text-md text-gray-700">ğŸ“ ì œëª© ìŠ¤íƒ€ì¼</h4>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="mainFontSelector" class="font-semibold text-gray-600 text-sm">ê¸€ê¼´</label>
                                    <select id="mainFontSelector" class="w-full p-2 mt-1 border rounded-md focus:ring-2 focus:ring-gray-300"></select>
                                </div>
                                <div>
                                    <label for="mainFontColorPicker" class="font-semibold text-gray-600 text-sm">ê¸€ì ìƒ‰</label>
                                    <input type="color" id="mainFontColorPicker" class="w-full h-10 p-1 mt-1 border rounded-md cursor-pointer hover:shadow-md">
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="mainTextStrokeColorPicker" class="font-semibold text-gray-600 text-sm">í…Œë‘ë¦¬ ìƒ‰</label>
                                    <input type="color" id="mainTextStrokeColorPicker" value="#FFFFFF" class="w-full h-10 p-1 mt-1 border rounded-md cursor-pointer hover:shadow-md">
                                </div>
                                <div>
                                    <label for="mainTextStrokeSlider" class="font-semibold text-gray-600 text-sm">í…Œë‘ë¦¬ êµµê¸°: <span id="mainTextStrokeValue">0</span>px</label>
                                    <input type="range" id="mainTextStrokeSlider" min="0" max="10" value="0" class="w-full mt-1 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                                </div>
                            </div>
                            <div>
                                <label for="mainFontSizeSlider" class="font-semibold text-gray-600">ê¸€ì í¬ê¸°: <span id="mainFontSizeValue">50</span>px</label>
                                <input type="range" id="mainFontSizeSlider" min="20" max="150" value="50" class="w-full mt-2 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                            </div>
                        </div>

                        <div class="p-4 border rounded-xl space-y-4 bg-gray-50">
                            <h4 class="font-bold text-md text-gray-700">ğŸ“Œ ì„¤ëª… ê¸€ ìŠ¤íƒ€ì¼</h4>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="subFontSelector" class="font-semibold text-gray-600 text-sm">ê¸€ê¼´</label>
                                    <select id="subFontSelector" class="w-full p-2 mt-1 border rounded-md focus:ring-2 focus:ring-gray-300"></select>
                                </div>
                                <div>
                                    <label for="subFontColorPicker" class="font-semibold text-gray-600 text-sm">ê¸€ì ìƒ‰</label>
                                    <input type="color" id="subFontColorPicker" class="w-full h-10 p-1 mt-1 border rounded-md cursor-pointer hover:shadow-md">
                                </div>
                            </div>
                            <div>
                                <label for="subFontSizeSlider" class="font-semibold text-gray-600">ê¸€ì í¬ê¸°: <span id="subFontSizeValue">25</span>px</label>
                                <input type="range" id="subFontSizeSlider" min="10" max="75" value="25" class="w-full mt-2 h-3 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                            </div>
                        </div>
                    </div>
                     <div id="tab-save" class="tab-content hidden space-y-4">
                        <p class="text-center text-gray-600 text-lg font-medium">âœ¨ ì‘í’ˆì´ ì™„ì„±ë˜ì—ˆì–´ìš”!<br/>ì›í•˜ëŠ” í˜•ì‹ìœ¼ë¡œ ì €ì¥í•˜ì„¸ìš”</p>
                        <button id="downloadPngBtn" class="w-full bg-blue-600 text-white p-4 rounded-xl font-bold text-lg shadow-xl hover:bg-blue-700 transition-all duration-300 transform hover:scale-[1.01]">
                            ğŸ–¼ï¸ PNGë¡œ ì €ì¥ (ìµœê³  í™”ì§ˆ - ì¶”ì²œ)
                        </button>
                        <button id="downloadJpgBtn" class="w-full bg-gray-800 text-white p-4 rounded-xl font-bold text-lg shadow-xl hover:bg-gray-900 transition-all duration-300 transform hover:scale-[1.01]">
                            ğŸ“· JPEGë¡œ ì €ì¥ (ì¼ë°˜ í™”ì§ˆ)
                        </button>
                        <div class="pt-4">
                            <button id="resetBtn" class="w-full bg-red-500 text-white p-3 rounded-xl font-semibold text-base shadow-lg hover:bg-red-600 transition-all duration-300 transform hover:scale-[1.01]">
                                ğŸ”„ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•˜ê¸°
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <div id="loader" class="fixed inset-0 bg-white bg-opacity-75 hidden justify-center items-center z-50">
        <div class="w-16 h-16 border-4 border-gray-900 border-t-transparent rounded-full animate-spin"></div>
    </div>

    <script>
        // --- ì „ì—­ ë³€ìˆ˜ ë° ì„¤ì • ---
        const MAX_IMAGES = 6;
        const canvas = document.getElementById('photoCanvas');
        const ctx = canvas.getContext('2d');
        const mainTextOverlay = document.getElementById('mainTextOverlay');
        const subTextOverlay = document.getElementById('subTextOverlay');
        let imageSlots = [];      // ìº”ë²„ìŠ¤ì— ê·¸ë ¤ì§„ ì´ë¯¸ì§€ ìœ„ì¹˜ ì •ë³´
        let draggedItem = null;
        let isDraggingText = false; // í…ìŠ¤íŠ¸ ë“œë˜ê·¸ ì¤‘ì¸ì§€ í™•ì¸í•˜ëŠ” í”Œë˜ê·¸

        // ğŸ¨ í…Œë§ˆ í”„ë¦¬ì…‹ (ìƒì—…ì  ë””ìì¸ ê¸°ì¤€ ê°•í™” ë° í¬ë¦¬ìŠ¤ë§ˆìŠ¤ ì¶”ê°€)
        const themes = {
            'modern-matte': { name: 'âœ¨ ëª¨ë˜ ë§¤íŠ¸', bg: '#f7f7f7', frame: '#ffffff', text: '#333333', font: 'Noto Sans KR' },
            'dark-edition': { name: 'ğŸŒ‘ ë‹¤í¬ ì—ë””ì…˜', bg: '#1A1A1A', frame: '#333333', text: '#EDEDED', font: 'Inter' },
            'christmas-dream': { name: 'ğŸ„ í¬ë¦¬ìŠ¤ë§ˆìŠ¤ ë“œë¦¼', bg: '#F8F8F8', frame: '#C0392B', text: '#1E8449', font: 'Permanent Marker' },
            'film-sepia': { name: 'ğŸï¸ ë¹ˆí‹°ì§€ í•„ë¦„', bg: '#E8D5C4', frame: '#fffaf2', text: '#584B3C', filter: 'sepia', font: 'Nanum Pen Script' },
            'monochrome': { name: 'âš«ï¸ ëª¨ë…¸í¬ë¡¬', bg: '#e5e5e5', frame: '#f9f9f9', text: '#0a0a0a', filter: 'grayscale', font: 'Gothic A1' },
            'cozy-coffee': { name: 'â˜•ï¸ í¬ê·¼í•œ ì¹´í˜', bg: '#F9F5E9', frame: '#FFFFFF', text: '#6D4C41', font: 'Caveat' },
            'vibrant-retro': { name: 'ğŸ’– ë„¤ì˜¨ íŒ', bg: '#FFE3E3', frame: '#F0F0FF', text: '#8A2BE2', font: 'Jua' },
            'spring-blossom': { name: 'ğŸŒ¸ ë²šê½ƒ ì—ë””ì…˜', bg: '#FFFAFF', frame: '#FFE4E1', text: '#DB7093', font: 'Gothic A1' },
            'deep-ocean': { name: 'ğŸŒŠ ë”¥ ì˜¤ì…˜', bg: '#004D73', frame: '#FFFFFF', text: '#FFC300', font: 'Lobster' },
            'korean-classic': { name: 'ğŸ‡°ğŸ‡· í•œêµ­ì˜ ë¯¸', bg: '#F3EFE9', frame: '#FFFFFF', text: '#3C583C', font: 'Do Hyeon' },
            'travel-blue': { name: 'âœˆï¸ íŠ¸ë˜ë¸” ë¸”ë£¨', bg: '#ADD8E6', frame: '#FFFFFF', text: '#004D73', font: 'Inter' },
            'summer-vivid': { name: 'â˜€ï¸ ì¨ë¨¸ ë¹„ë¹„ë“œ', bg: '#00bcd4', frame: '#FFFFFF', text: '#facc15', font: 'Jua' },
            'earth-tone': { name: 'ğŸ‚ ì–¼ìŠ¤í†¤ ë¬´ë“œ', bg: '#DBC3A0', frame: '#FFFFFF', text: '#4A4E69', font: 'Gothic A1' },
            'cyber-punk': { name: 'ğŸ‘¾ ì‚¬ì´ë²„ í‘í¬', bg: '#231942', frame: '#5E548E', text: '#9F86C0', font: 'Inter' },
            'pastel-lavender': { name: 'ğŸ’œ íŒŒìŠ¤í…” ë¼ë²¤ë”', bg: '#EBEBF8', frame: '#F0F0F8', text: '#6A5ACD', font: 'Noto Sans KR' },
        };
        
        // === getCurrentDateFormatted ===
        // ì˜¤ëŠ˜ ë‚ ì§œë¥¼ "2025. 12. 22."ì²˜ëŸ¼ ì˜ˆì˜ê²Œ ë§Œë“¤ì–´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ì•±ì„ ì²˜ìŒ ì¼œê±°ë‚˜ ìƒˆë¡œ ì‹œì‘í•  ë•Œ ë‚ ì§œë¥¼ ìë™ìœ¼ë¡œ ë„£ì–´ì¤˜ìš”.
        function getCurrentDateFormatted() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0'); // 0-indexed
            const day = String(now.getDate()).padStart(2, '0');
            return `${year}. ${month}. ${day}.`;
        }

        let defaultConfig = {
            images: [], 
            layout: '1x4',
            theme: 'modern-matte', 
            backgroundColor: themes['modern-matte'].bg,
            frameColor: themes['modern-matte'].frame,
            frameMargin: 5, // %
            imagePadding: 5, // %
            imageCornerRadius: 0, // NEW: ì‚¬ì§„ ëª¨ì„œë¦¬ ë‘¥ê¸€ê¸° (px)
            mainText: {
                content: 'LIFE 4 CUTS', font: 'Noto Sans KR', size: 50, 
                color: themes['modern-matte'].text, position: 'bottom', x: 0.5, y: 0,
                strokeColor: '#FFFFFF', // NEW: í…Œë‘ë¦¬ ìƒ‰ìƒ
                strokeWidth: 0 // NEW: í…Œë‘ë¦¬ ë‘ê»˜
            },
            subText: {
                // í˜„ì¬ ë‚ ì§œë¡œ ìë™ ì„¤ì •
                content: getCurrentDateFormatted(), 
                font: 'Noto Sans KR', size: 25, color: themes['modern-matte'].text, x: 0.5, y: 0 
            }
        };
        let config = JSON.parse(JSON.stringify(defaultConfig));
        
        // --- í°íŠ¸ ëª©ë¡ (JSë¡œ ê´€ë¦¬, íŠ¸ë Œë”” í°íŠ¸ ì¶”ê°€) ---
        const fontList = [
            { value: 'Inter', name: 'Inter (ê¸°ë³¸ ì˜ë¬¸)' },
            { value: 'Noto Sans KR', name: 'ë³¸ê³ ë”• (ê¹”ë”/ëª¨ë˜)' },
            { value: 'Jua', name: 'ì£¼ì•„ (êµµì€ ì œëª©)' },
            { value: 'Nanum Pen Script', name: 'ë‚˜ëˆ”ì†ê¸€ì”¨ íœ' },
            { value: 'Gothic A1', name: 'ê³ ë”• A1 (ëª¨ë˜)' },
            { value: 'Do Hyeon', name: 'ë„í˜„ (í•œêµ­ì )' },
            { value: 'Caveat', name: 'Caveat (í•„ê¸°ì²´)' },
            { value: 'Lobster', name: 'Lobster (ì˜ë¬¸ ì œëª©)' },
            { value: 'Permanent Marker', name: 'Permanent Marker' },
        ];

        const slotOverlayCache = new Map(); // { index: DOM element }
        let selectedSlotIndex = null;       // í”„ë ˆì„ì˜ ì„ íƒëœ ìŠ¬ë¡¯
        let selectedPreviewIndex = null;    // ë¯¸ë¦¬ë³´ê¸°ì˜ ì„ íƒëœ ì‚¬ì§„
        let isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);  // ëª¨ë°”ì¼ íŒì •

        
        // --- ì´ˆê¸°í™” ---
        window.onload = () => {
            setupEventListeners();
            populateThemeButtons();
            populateFontSelectors(); 
            updateUIFromConfig();
            setupTabs();
            // ìº”ë²„ìŠ¤ ì´ˆê¸° í¬ê¸° ì„¤ì • í›„ ë“œë¡œì‰
            setTimeout(() => {
                resizeCanvas();
                if (config.mainText.y === 0) initializeTextPositions();
                drawCanvas(); 
            }, 500); 
        };

        // === populateFontSelectors ===
        // ê¸€ì”¨ì²´ ê³ ë¥´ëŠ” ë©”ë‰´(ë“œë¡­ë‹¤ìš´)ë¥¼ ì±„ì›Œì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ë©”ì¸ ê¸€ìì™€ ì‘ì€ ê¸€ì ëª¨ë‘ ê°™ì€ ê¸€ì”¨ì²´ ëª©ë¡ì„ ë³´ì—¬ì¤˜ìš”.
        function populateFontSelectors() {
            const mainSelector = document.getElementById('mainFontSelector');
            const subSelector = document.getElementById('subFontSelector');
            
            // ê¸°ì¡´ ì˜µì…˜ ì œê±°
            mainSelector.innerHTML = '';
            subSelector.innerHTML = '';

            fontList.forEach(font => {
                const mainOption = new Option(font.name, font.value);
                const subOption = new Option(font.name, font.value);
                mainSelector.add(mainOption);
                subSelector.add(subOption);
            });
        }

        // === setupEventListeners ===
        // ì•±ì—ì„œ ë²„íŠ¼ ëˆ„ë¥´ê¸°, ì‚¬ì§„ ì˜¬ë¦¬ê¸°, ìŠ¬ë¼ì´ë” ì›€ì§ì´ê¸°, ê¸€ì ì“°ê¸° ë“± ëª¨ë“  ë™ì‘ì„ ê°ì§€í•´ì„œ "ì´ê±¸ ëˆ„ë¥´ë©´ ì´ ì¼ì´ ì¼ì–´ë‚˜!"ë¼ê³  ì—°ê²°í•´ ì£¼ëŠ” í° í•¨ìˆ˜ì˜ˆìš”.
        function setupEventListeners() {
            // ì´ë¯¸ì§€ ì—…ë¡œë“œ
            const dropZone = document.getElementById('dropZone');
            dropZone.addEventListener('click', () => document.getElementById('imageUpload').click());
            dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drag-over'); });
            dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('drag-over'); });
            dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('drag-over'); handleFiles(e.dataTransfer.files); });
            document.getElementById('imageUpload').addEventListener('change', (e) => handleFiles(e.target.files));
            document.getElementById('cameraUpload').addEventListener('change', (e) => handleFiles(e.target.files));

            // ë””ìì¸
            document.getElementById('layoutButtons').addEventListener('click', (e) => {
                let targetButton = e.target.closest('.control-btn');
                if (targetButton) { 
                    config.layout = targetButton.dataset.layout; 
                    updateActiveButton(document.getElementById('layoutButtons'), targetButton); 
                    resizeCanvas(); 
                    initializeTextPositions(); 
                    drawCanvas(); 
                }
            });
            document.getElementById('frameMarginSlider').addEventListener('input', (e) => { config.frameMargin = parseInt(e.target.value); document.getElementById('frameMarginValue').textContent = e.target.value; drawCanvas(); });
            document.getElementById('imagePaddingSlider').addEventListener('input', (e) => { config.imagePadding = parseInt(e.target.value); document.getElementById('imagePaddingValue').textContent = e.target.value; drawCanvas(); });
            // NEW LISTENER: Image Corner Radius
            document.getElementById('imageRadiusSlider').addEventListener('input', (e) => { config.imageCornerRadius = parseInt(e.target.value); document.getElementById('imageRadiusValue').textContent = e.target.value; drawCanvas(); });
            
            document.getElementById('backgroundColorPicker').addEventListener('input', (e) => { config.backgroundColor = e.target.value; drawCanvas(); });
            document.getElementById('frameColorPicker').addEventListener('input', (e) => { config.frameColor = e.target.value; drawCanvas(); });
            
            // í…ìŠ¤íŠ¸ ìœ„ì¹˜ ì„¤ì •
            document.getElementById('textPositionButtons').addEventListener('click', (e) => {
                let targetButton = e.target.closest('button');
                if (targetButton && targetButton.dataset.position) { 
                    config.mainText.position = targetButton.dataset.position; 
                    updateActiveButton(document.getElementById('textPositionButtons'), targetButton); 
                    initializeTextPositions(); 
                    drawCanvas(); 
                }
            });
            document.getElementById('customTextInput').addEventListener('input', (e) => { config.mainText.content = e.target.value; updateTextOverlay(); drawCanvas(); });
            document.getElementById('subTextInput').addEventListener('input', (e) => { config.subText.content = e.target.value; updateTextOverlay(); drawCanvas(); });
            
            
            // --- ë©”ì¸ ë¬¸êµ¬ ì „ìš© ë¦¬ìŠ¤ë„ˆ ---
            document.getElementById('mainFontSelector').addEventListener('change', (e) => { 
                config.mainText.font = e.target.value; 
                updateTextOverlay(); drawCanvas(); 
            });
            document.getElementById('mainFontSizeSlider').addEventListener('input', (e) => {
                config.mainText.size = parseInt(e.target.value);
                document.getElementById('mainFontSizeValue').textContent = e.target.value;
                updateTextOverlay(); drawCanvas();
            });
            document.getElementById('mainFontColorPicker').addEventListener('input', (e) => { 
                config.mainText.color = e.target.value; 
                updateTextOverlay(); drawCanvas(); 
            });
            // NEW LISTENER: Main Text Stroke
            document.getElementById('mainTextStrokeColorPicker').addEventListener('input', (e) => { 
                config.mainText.strokeColor = e.target.value; 
                updateTextOverlay(); drawCanvas(); 
            });
            document.getElementById('mainTextStrokeSlider').addEventListener('input', (e) => {
                config.mainText.strokeWidth = parseInt(e.target.value);
                document.getElementById('mainTextStrokeValue').textContent = e.target.value;
                updateTextOverlay(); drawCanvas();
            });


            // --- ë³´ì¡° ë¬¸êµ¬ ì „ìš© ë¦¬ìŠ¤ë„ˆ ---
            document.getElementById('subFontSelector').addEventListener('change', (e) => { 
                config.subText.font = e.target.value; 
                updateTextOverlay(); drawCanvas(); 
            });
            document.getElementById('subFontSizeSlider').addEventListener('input', (e) => {
                config.subText.size = parseInt(e.target.value);
                document.getElementById('subFontSizeValue').textContent = e.target.value;
                updateTextOverlay(); drawCanvas();
            });
            document.getElementById('subFontColorPicker').addEventListener('input', (e) => { 
                config.subText.color = e.target.value; 
                updateTextOverlay(); drawCanvas(); 
            });

            // ì €ì¥
            // ğŸ’¡ [ì—…ê·¸ë ˆì´ë“œ] PNG ë²„íŠ¼: ëª¨ë°”ì¼ í™˜ê²½ì—ì„œ ê°¤ëŸ¬ë¦¬ ì €ì¥ ì‹œë„
            document.getElementById('downloadPngBtn').addEventListener('click', async () => {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) {
                    await saveToGallery('png');
                } else {
                    downloadImage('png');
                }
            });
            
            // ğŸ’¡ [ì—…ê·¸ë ˆì´ë“œ] JPEG ë²„íŠ¼: ëª¨ë°”ì¼ í™˜ê²½ì—ì„œ ê°¤ëŸ¬ë¦¬ ì €ì¥ ì‹œë„
            document.getElementById('downloadJpgBtn').addEventListener('click', async () => {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) {
                    await saveToGallery('jpeg'); 
                } else {
                    downloadImage('jpeg');
                }
            });
            document.getElementById('resetBtn').addEventListener('click', () => { if(confirm('ì •ë§ë¡œ ëª¨ë“  ì‘ì—…ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) resetApp(); });

            // í…ìŠ¤íŠ¸ ë“œë˜ê·¸ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            addTextDragListeners(mainTextOverlay, 'mainText');
            addTextDragListeners(subTextOverlay, 'subText');
        }

        // === updateUIFromConfig ===
        // ì§€ê¸ˆ ì„¤ì •í•œ ëª¨ë“  ê²ƒ(ìƒ‰ê¹”, ê¸€ì”¨ í¬ê¸°, ìœ„ì¹˜ ë“±)ì„ í™”ë©´ì˜ ë²„íŠ¼ê³¼ ìŠ¬ë¼ì´ë”ì— ë˜‘ê°™ì´ ë³´ì—¬ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ì„¤ì • ë°”ê¾¸ë©´ ë°”ë¡œ í™”ë©´ë„ ë°”ë€Œê²Œ í•´ì¤˜ìš”.
        function updateUIFromConfig() {
            // í…Œë§ˆ ë° ë ˆì´ì•„ì›ƒ, ìœ„ì¹˜ ë²„íŠ¼ í™œì„±í™”
            updateActiveButton(document.getElementById('themeButtons'), document.querySelector(`[data-theme="${config.theme}"]`));
            updateActiveButton(document.getElementById('layoutButtons'), document.querySelector(`[data-layout="${config.layout}"]`));
            updateActiveButton(document.getElementById('textPositionButtons'), document.querySelector(`[data-position="${config.mainText.position}"]`));
            
            // ìƒ‰ìƒ ë° ë§ˆì§„ ìŠ¬ë¼ì´ë”
            document.getElementById('backgroundColorPicker').value = config.backgroundColor;
            document.getElementById('frameColorPicker').value = config.frameColor;
            document.getElementById('frameMarginSlider').value = config.frameMargin;
            document.getElementById('frameMarginValue').textContent = config.frameMargin;
            document.getElementById('imagePaddingSlider').value = config.imagePadding;
            document.getElementById('imagePaddingValue').textContent = config.imagePadding;
            // NEW UI UPDATE: Image Corner Radius
            document.getElementById('imageRadiusSlider').value = config.imageCornerRadius;
            document.getElementById('imageRadiusValue').textContent = config.imageCornerRadius;

            // í…ìŠ¤íŠ¸ ë‚´ìš©
            document.getElementById('customTextInput').value = config.mainText.content;
            document.getElementById('subTextInput').value = config.subText.content; // í˜„ì¬ ë‚ ì§œë¡œ ì´ˆê¸°í™”ëœ ê°’ ì‚¬ìš©
            
            // ë©”ì¸ í…ìŠ¤íŠ¸ UI ì—…ë°ì´íŠ¸
            document.getElementById('mainFontSelector').value = config.mainText.font;
            document.getElementById('mainFontSizeSlider').value = config.mainText.size;
            document.getElementById('mainFontSizeValue').textContent = config.mainText.size;
            document.getElementById('mainFontColorPicker').value = config.mainText.color;
            // NEW UI UPDATE: Main Text Stroke
            document.getElementById('mainTextStrokeColorPicker').value = config.mainText.strokeColor;
            document.getElementById('mainTextStrokeSlider').value = config.mainText.strokeWidth;
            document.getElementById('mainTextStrokeValue').textContent = config.mainText.strokeWidth;
            
            // ë³´ì¡° í…ìŠ¤íŠ¸ UI ì—…ë°ì´íŠ¸
            document.getElementById('subFontSelector').value = config.subText.font;
            document.getElementById('subFontSizeSlider').value = config.subText.size;
            document.getElementById('subFontSizeValue').textContent = config.subText.size;
            document.getElementById('subFontColorPicker').value = config.subText.color;
            
            updateTextOverlay(); // ì˜¤ë²„ë ˆì´ ìœ„ì¹˜/ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
        }


        // === resetApp ===
        // "ì²˜ìŒìœ¼ë¡œ!" ë²„íŠ¼ì²˜ëŸ¼ ëª¨ë“  ê±¸ ê¹¨ë—ì´ ì§€ìš°ê³  ì²˜ìŒ ìƒíƒœë¡œ ëŒë ¤ë†“ëŠ” í•¨ìˆ˜ì˜ˆìš”. ì‚¬ì§„ë„ ì—†ì• ê³  ë‚ ì§œë„ ì˜¤ëŠ˜ë¡œ ë‹¤ì‹œ ë„£ì–´ìš”.
        function resetApp() {
            // ë¦¬ì…‹ ì‹œì—ë„ í˜„ì¬ ë‚ ì§œë¡œ ì´ˆê¸°í™”
            defaultConfig.subText.content = getCurrentDateFormatted(); 
            config = JSON.parse(JSON.stringify(defaultConfig));
            slotOverlayCache.clear();
            updateUIFromConfig();
            renderImagePreviews();
            resizeCanvas();
            initializeTextPositions();
            drawCanvas();
        }

        // === setupTabs ===
        // ìœ„ì— ìˆëŠ” íƒ­(ì‚¬ì§„ ê´€ë¦¬, ë””ìì¸, í…ìŠ¤íŠ¸, ì €ì¥)ì„ ëˆ„ë¥´ë©´ í•´ë‹¹ í˜ì´ì§€ë§Œ ë³´ì—¬ì£¼ê³  ë‚˜ë¨¸ì§€ëŠ” ìˆ¨ê¸°ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function setupTabs() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.dataset.tab;
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    tabContents.forEach(content => content.id === tabId ? content.classList.remove('hidden') : content.classList.add('hidden'));
                });
            });
        }

        // === populateThemeButtons ===
        // ì˜ˆìœ í…Œë§ˆ(ìƒ‰ ì¡°í•©) ë²„íŠ¼ë“¤ì„ ìë™ìœ¼ë¡œ ë§Œë“¤ì–´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ë²„íŠ¼ ëˆ„ë¥´ë©´ ë°°ê²½ìƒ‰, ê¸€ììƒ‰, í”„ë ˆì„ìƒ‰ì´ í•œ ë²ˆì— ë°”ë€Œì–´ìš”.
        function populateThemeButtons() {
            const container = document.getElementById('themeButtons');
            container.innerHTML = '';
            for (const [key, theme] of Object.entries(themes)) {
                const button = document.createElement('button');
                button.className = 'control-btn p-3 rounded-xl shadow-sm border text-sm font-semibold transition-all duration-200 text-center bg-white hover:shadow-md';
                // í…Œë§ˆ ìƒ‰ìƒì„ ë” ì˜ ë³´ì—¬ì£¼ê¸° ìœ„í•´ í”„ë ˆì„ ìƒ‰ìƒì´ í°ìƒ‰ì¼ ê²½ìš° í…Œë‘ë¦¬ë¥¼ ì§€ì •
                const frameBorderColor = theme.frame === '#ffffff' || theme.frame === '#f9f9f9' || theme.frame === '#fffaf2' || theme.frame === '#F0F0F8' ? '#d1d5db' : theme.frame;
                button.innerHTML = `<div class="w-full h-4 rounded mb-2 border-2" style="background-color: ${theme.bg}; border-color: ${frameBorderColor};"></div>${theme.name}`;
                button.dataset.theme = key;
                button.addEventListener('click', () => {
                    config.theme = key; 
                    config.backgroundColor = theme.bg; 
                    config.frameColor = theme.frame;
                    config.mainText.color = theme.text; 
                    config.subText.color = theme.text;
                    
                    if(theme.font) {
                        config.mainText.font = theme.font;
                        config.subText.font = theme.font;
                    } else { // í°íŠ¸ê°€ ì§€ì •ë˜ì§€ ì•Šì€ ê²½ìš° ê¸°ë³¸ í°íŠ¸ë¥¼ ì‚¬ìš©
                        config.mainText.font = 'Noto Sans KR';
                        config.subText.font = 'Noto Sans KR';
                    }
                    
                    // í•„í„° ì„¤ì •
                    const newFilter = theme.filter || null;
                    config.images = config.images.map(img => ({...img, filter: newFilter}));
                    
                    updateUIFromConfig(); 
                    drawCanvas();
                    renderImagePreviews(); // ë¯¸ë¦¬ë³´ê¸°ì—ë„ í•„í„°ë¥¼ ì ìš©í•´ì•¼ í•˜ë¯€ë¡œ í˜¸ì¶œ
                });
                container.appendChild(button);
            }
        }
        
        function updateActiveButton(container, activeButton) {
            container.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
            if (activeButton) activeButton.classList.add('active');
        }

        function moveImage(index, direction) {
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= config.images.length) return;

            // ë°°ì—´ swap
            [config.images[index], config.images[newIndex]] =
            [config.images[newIndex], config.images[index]];

            renderImagePreviews();
            drawCanvas();
            }

        // --- ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì ˆ í•¨ìˆ˜ ---
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            let aspectRatio;
            switch(config.layout) {
                case '1x4': aspectRatio = 3; break;
                case '2x2': aspectRatio = 1.5; break;
                case '1+3': aspectRatio = 2; break; 
                case '2+3': aspectRatio = 1.8; break; 
                case '2x3': aspectRatio = 2.2; break; 
                case '3x2': aspectRatio = 1.2; break; 
                default: aspectRatio = 3;
            }

            // âœ… 1ë‹¨ê³„: CSS í¬ê¸° ì„¤ì • (í™”ë©´ì— ë³´ì´ëŠ” í¬ê¸°)
            canvas.style.width = `${rect.width}px`;
            const displayHeight = rect.width * aspectRatio;
            canvas.style.height = `${displayHeight}px`;
            
            // âœ… 2ë‹¨ê³„: DPR ê°’ ì–»ê¸° (ê³ í•´ìƒë„ ë””ë°”ì´ìŠ¤ ëŒ€ì‘)
            const dpr = window.devicePixelRatio || 1;
            
            // âœ… 3ë‹¨ê³„: ë¬¼ë¦¬ì  í”½ì…€ í¬ê¸° ì„¤ì • (DPR í¬í•¨)
            // ì˜ˆ: iPhoneì˜ DPRì´ 2ì´ë©´, CSS 350px = ë¬¼ë¦¬ 700px
            canvas.width = rect.width * dpr; 
            canvas.height = displayHeight * dpr;
            ctx.scale(dpr, dpr); 
            
            // âœ… 4ë‹¨ê³„: ë‹¤ë¥¸ í•¨ìˆ˜ì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ canvasì— ì €ì¥
            //         drawCanvas()ì—ì„œ ì´ ê°’ë“¤ì„ ì‚¬ìš©!
            canvas.displayWidth = rect.width;        // CSS í”½ì…€ ë„ˆë¹„
            canvas.displayHeight = displayHeight;    // CSS í”½ì…€ ë†’ì´
            canvas.dpr = dpr;                        // ë””ë°”ì´ìŠ¤ í”½ì…€ ë¹„ìœ¨
        }


        // === initializeTextPositions ===
        // ê¸€ìë¥¼ ì²˜ìŒì— ì–´ë””ì— ë‘˜ì§€(ìœ„ìª½, ê°€ìš´ë°, ì•„ë˜ìª½) ì •í•´ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ë‚˜ì¤‘ì— ì§ì ‘ ëŒì–´ì„œ ì˜®ê¸¸ ìˆ˜ ìˆì§€ë§Œ ì²˜ìŒ ìœ„ì¹˜ë¥¼ ì¡ì•„ì¤˜ìš”.
        function initializeTextPositions() {
            const W = canvas.parentElement.getBoundingClientRect().width;
            const H = canvas.parentElement.getBoundingClientRect().height;
            const margin = W * (config.frameMargin / 100);
            const p = W * (config.imagePadding / 100); 

            let mainY, subY;
            
            // âœ¨ ìˆ˜ì •: í°íŠ¸ í¬ê¸° ì¶”ì •ì¹˜ ê³„ì‚° ì‹œ ë¶ˆí•„ìš”í•œ ìŠ¤ì¼€ì¼ íŒ©í„° ì œê±° (W, H, size ëª¨ë‘ CSS í”½ì…€ ë‹¨ìœ„)
            const mainTextHeightEst = config.mainText.size * 1.2; 
            const subTextHeightEst = config.subText.size * 1.2; 

            if (config.mainText.position === 'bottom') {
                mainY = H - margin - p - (mainTextHeightEst / 2);
                subY = margin + p + (subTextHeightEst / 2); 
            } else if (config.mainText.position === 'top') {
                mainY = margin + p + (mainTextHeightEst / 2);
                subY = H - margin - p - (subTextHeightEst / 2); 
            } else { // center
                mainY = H / 2 - subTextHeightEst;
                subY = H / 2 + mainTextHeightEst; 
            }
            
            // ìœ„ì¹˜ë¥¼ ë¹„ìœ¨(0.0 ~ 1.0)ë¡œ ì €ì¥
            config.mainText.x = 0.5;
            config.mainText.y = mainY / H; 
            config.subText.x = 0.5;
            config.subText.y = subY / H; 
            
            updateTextOverlay(); 
        }

        // --- í…ìŠ¤íŠ¸ ì˜¤ë²„ë ˆì´(ë“œë˜ê·¸ìš©) ì—…ë°ì´íŠ¸ ---
        function updateTextOverlay() {
            const { mainText, subText } = config;
            
            // âœ… 1ë‹¨ê³„: canvasContainerë¥¼ ê¸°ì¤€ì ìœ¼ë¡œ ì„¤ì •
            //          (ì´ê²Œ í…ìŠ¤íŠ¸ ì˜¤ë²„ë ˆì´ì˜ ë¶€ëª¨ ìš”ì†Œ)
            const containerRect = document.getElementById('canvasContainer').getBoundingClientRect();
            const dW = containerRect.width;   // canvasContainerì˜ ë„ˆë¹„
            const dH = containerRect.height;  // canvasContainerì˜ ë†’ì´
            
            // ========================================================
            // ë©”ì¸ í…ìŠ¤íŠ¸ ì„¤ì •
            // ========================================================
            
            // âœ… 2ë‹¨ê³„: ë©”ì¸ í…ìŠ¤íŠ¸ ì½˜í…ì¸  ì—…ë°ì´íŠ¸
            mainTextOverlay.textContent = mainText.content;
            mainTextOverlay.style.color = mainText.color;
            mainTextOverlay.style.fontFamily = mainText.font;
            mainTextOverlay.style.fontSize = `${mainText.size}px`;
            mainTextOverlay.style.fontWeight = 'bold';
            
            // âœ… 3ë‹¨ê³„: ìŠ¤íŠ¸ë¡œí¬ (í…Œë‘ë¦¬) íš¨ê³¼ ì¶”ê°€
            //          ê¸°ì¡´: 4ë°©í–¥ë§Œ â†’ ë¬¸ì œ: í…Œë‘ë¦¬ê°€ ì•½í•¨
            //          ê°œì„ : 8ë°©í–¥ìœ¼ë¡œ â†’ ë” ì§„í•œ í…Œë‘ë¦¬
            let shadow = 'none';
            if (mainText.strokeWidth > 0) {
                const sw = mainText.strokeWidth;
                const sc = mainText.strokeColor;
                
                // 8ë°©í–¥ìœ¼ë¡œ í™•ì¥ëœ í…ìŠ¤íŠ¸ ì„€ë„ìš°
                // ì˜¤ë¥¸ìª½, ì™¼ìª½, ìœ„, ì•„ë˜, ëŒ€ê°ì„  4ê°œ ë°©í–¥
                shadow = `
                    ${sc} ${sw}px 0,        /* ì˜¤ë¥¸ìª½ */
                    ${sc} ${-sw}px 0,       /* ì™¼ìª½ */
                    ${sc} 0 ${sw}px,        /* ì•„ë˜ */
                    ${sc} 0 ${-sw}px,       /* ìœ„ */
                    ${sc} ${sw}px ${sw}px,     /* ì˜¤ë¥¸ìª½ ì•„ë˜ ëŒ€ê°ì„  */
                    ${sc} ${-sw}px ${-sw}px,   /* ì™¼ìª½ ìœ„ ëŒ€ê°ì„  */
                    ${sc} ${sw}px ${-sw}px,    /* ì˜¤ë¥¸ìª½ ìœ„ ëŒ€ê°ì„  */
                    ${sc} ${-sw}px ${sw}px     /* ì™¼ìª½ ì•„ë˜ ëŒ€ê°ì„  */
                `;
            }
            mainTextOverlay.style.textShadow = shadow;

            // âœ… 4ë‹¨ê³„: ë©”ì¸ í…ìŠ¤íŠ¸ ìœ„ì¹˜ ê³„ì‚°
            const mainTextWidth = mainTextOverlay.offsetWidth;    // ë Œë”ëœ í…ìŠ¤íŠ¸ì˜ ì‹¤ì œ ë„ˆë¹„
            const mainTextHeight = mainTextOverlay.offsetHeight;  // ë Œë”ëœ í…ìŠ¤íŠ¸ì˜ ì‹¤ì œ ë†’ì´
            
            // ì¤‘ì•™ ì •ë ¬ ê³„ì‚°:
            // (dW * mainText.x) = ì»¨í…Œì´ë„ˆì—ì„œ í…ìŠ¤íŠ¸ ì¤‘ì‹¬ì˜ X ì¢Œí‘œ
            // (mainTextWidth / 2) = í…ìŠ¤íŠ¸ í¬ê¸°ì˜ ì ˆë°˜ì„ ë¹¼ì„œ í…ìŠ¤íŠ¸ê°€ ì¤‘ì•™ì— ì˜¤ë„ë¡
            mainTextOverlay.style.left = `${(dW * mainText.x) - (mainTextWidth / 2)}px`;
            mainTextOverlay.style.top = `${(dH * mainText.y) - (mainTextHeight / 2)}px`;

            // ========================================================
            // ì„œë¸Œ í…ìŠ¤íŠ¸(ë‚ ì§œ/ì„¤ëª…) ì„¤ì •
            // ========================================================
            
            // âœ… 5ë‹¨ê³„: ì„œë¸Œ í…ìŠ¤íŠ¸ ì½˜í…ì¸  ì—…ë°ì´íŠ¸
            subTextOverlay.textContent = subText.content;
            subTextOverlay.style.color = subText.color;
            subTextOverlay.style.fontFamily = subText.font;
            subTextOverlay.style.fontSize = `${subText.size}px`;
            subTextOverlay.style.fontWeight = 'normal';
            
            // âœ… 6ë‹¨ê³„: ì„œë¸Œ í…ìŠ¤íŠ¸ ìœ„ì¹˜ ê³„ì‚°
            const subTextWidth = subTextOverlay.offsetWidth;
            const subTextHeight = subTextOverlay.offsetHeight;
            
            subTextOverlay.style.left = `${(dW * subText.x) - (subTextWidth / 2)}px`;
            subTextOverlay.style.top = `${(dH * subText.y) - (subTextHeight / 2)}px`;
        }

        // === addTextDragListeners ===
        // ê¸€ì ìƒìë¥¼ ë§ˆìš°ìŠ¤ë‚˜ ì†ê°€ë½ìœ¼ë¡œ ì¡ê³  ëŒ ìˆ˜ ìˆê²Œ í•´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ëŒë©´ì„œ ìœ„ì¹˜ê°€ ë°”ë€Œë©´ ê·¸ ìœ„ì¹˜ë¥¼ ê¸°ì–µí•´ ë‘¬ìš”.
        function addTextDragListeners(element, key) {
            let isDragging = false;
            let startClientX, startClientY; 
            let startElementX, startElementY; 

            const startDrag = (e) => {
                e.preventDefault();
                isDragging = true;
                isDraggingText = true;
                element.classList.add('dragging');
                drawCanvas();
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                startClientX = clientX;
                startClientY = clientY;
                
                const parentRect = element.parentElement.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
                
                startElementX = elementRect.left - parentRect.left;
                startElementY = elementRect.top - parentRect.top;

                element.style.cursor = 'grabbing';
            };

            const moveDrag = (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const dx = clientX - startClientX; 
                const dy = clientY - startClientY;

                let newX = startElementX + dx;
                let newY = startElementY + dy;
                
                const parentRect = element.parentElement.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect(); 
                const elementWidth = elementRect.width;
                const elementHeight = elementRect.height;

                // âœ¨ ìˆ˜ì •: frameMarginì´ ì•„ë‹Œ ì‘ì€ ì—¬ë°±ìœ¼ë¡œ í”„ë ˆì„ ë‚´ì—ì„œ ììœ ë¡­ê²Œ ì´ë™
                const minMargin = 5; // í”„ë ˆì„ í…Œë‘ë¦¬ë¡œë¶€í„° 5px ì—¬ìœ 

                // --- ê²½ê³„ê°’ ì²˜ë¦¬ (í”„ë ˆì„ ë‚´ì—ì„œë§Œ ì´ë™ ê°€ëŠ¥) ---
                newX = Math.max(newX, minMargin); 
                newX = Math.min(newX, parentRect.width - elementWidth - minMargin);
                newY = Math.max(newY, minMargin);
                newY = Math.min(newY, parentRect.height - elementHeight - minMargin);
                
                element.style.left = `${newX}px`;
                element.style.top = `${newY}px`;
                
                // í…ìŠ¤íŠ¸ì˜ "ì¤‘ì•™" ë¹„ìœ¨ì„ ì €ì¥í•˜ì—¬ ìº”ë²„ìŠ¤ ë Œë”ë§ê³¼ ë™ê¸°í™”
                const centerX = newX + (elementWidth / 2);
                const centerY = newY + (elementHeight / 2);

                config[key].x = centerX / parentRect.width;
                config[key].y = centerY / parentRect.height;
            };

            const endDrag = () => {
                if (isDragging) {
                    isDragging = false;
                    isDraggingText = false;
                    element.classList.remove('dragging');
                    element.style.cursor = 'grab';
                    drawCanvas();
                }
            };
            
            element.addEventListener('mousedown', startDrag);
            element.addEventListener('touchstart', startDrag, { passive: false });

            document.addEventListener('mousemove', moveDrag);
            document.addEventListener('touchmove', moveDrag, { passive: false });

            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
        }

        // === handleFiles ===
        // "ì‚¬ì§„ ê³¨ë¼!" í•˜ë©´ ì„ íƒí•œ ì‚¬ì§„ë“¤ì„ ì½ì–´ì„œ ì•± ì•ˆì— ë„£ì–´ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”. ë°”ë¡œ ë¯¸ë¦¬ë³´ê¸°ì™€ í° íŒì— ë³´ì—¬ì¤˜ìš”.
        async function handleFiles(files) {
            const fileList = Array.from(files).slice(0, MAX_IMAGES - config.images.length);
            if (fileList.length === 0) {
                 if(config.images.length >= MAX_IMAGES) alert(`ìµœëŒ€ ${MAX_IMAGES}ì¥ê¹Œì§€ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
                 return;
            }
            showLoader(true);
            const currentTheme = themes[config.theme];
            for (const file of fileList) {
                try {
                    const img = await loadImage(file);
                    config.images.push({ 
                        id: Date.now() + Math.random(), 
                        image: img,
                        // ì¹´ë©”ë¼ì—ì„œ ì°ì€ ì‚¬ì§„ì˜ ê²½ìš° ì¢Œìš° ë°˜ì „ ê¸°ë³¸ ì ìš©
                        flipped: (file.name && file.name.includes('image') && document.getElementById('cameraUpload').files.length > 0) ? true : false,
                        rotation: 0,
                        filter: currentTheme.filter || null // í…Œë§ˆì— ë§ëŠ” í•„í„° ì ìš©
                    });
                } catch (error) { console.error("Image loading failed:", error); }
            }
            renderImagePreviews(); drawCanvas(); showLoader(false);
            document.getElementById('imageUpload').value = null;
            document.getElementById('cameraUpload').value = null;
        }

        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => { const img = new Image(); img.onload = () => resolve(img); img.onerror = reject; img.src = e.target.result; };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // === renderImagePreviews ===
        // ì•„ë˜ìª½ì— ì‘ì€ ì‚¬ì§„ ì¸ë„¤ì¼ë“¤ì„ ë³´ì—¬ì£¼ê³ , ìˆœì„œ ë°”ê¾¸ê¸°Â·ì¢Œìš° ë’¤ì§‘ê¸°Â·íšŒì „í•˜ê¸°Â·ì§€ìš°ê¸°ë¥¼ í•  ìˆ˜ ìˆê²Œ í•´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function renderImagePreviews() {
            const container = document.getElementById('imagePreviews');
            container.innerHTML = '';
            
            config.images.forEach((imgData, index) => {
                const div = document.createElement('div');
                div.className = 'preview-item relative group aspect-square transition-all duration-300 cursor-pointer';
                div.dataset.index = index;
                div.draggable = true;
                
                // âœ… ì„ íƒëœ ë¯¸ë¦¬ë³´ê¸°ì— íŒŒë€ í…Œë‘ë¦¬ í‘œì‹œ
                if (selectedPreviewIndex === index) {
                    div.classList.add('selected');
                    div.style.outline = '3px solid #3b82f6';
                    div.style.outlineOffset = '2px';
                    div.style.boxShadow = '0 0 0 1px #3b82f6';
                }

                const img = document.createElement('img');
                img.src = imgData.image.src;
                img.className = 'w-full h-full object-cover rounded-lg shadow-md pointer-events-none';
                let transform = `scaleX(${imgData.flipped ? -1 : 1}) rotate(${imgData.rotation}deg)`;
                img.style.transform = transform;
                
                // í•„í„° ìŠ¤íƒ€ì¼ ì ìš©
                if(imgData.filter === 'grayscale') img.style.filter = 'grayscale(100%)';
                else if(imgData.filter === 'sepia') img.style.filter = 'sepia(100%)';
                else img.style.filter = 'none';

                const btnContainer = document.createElement('div');
                btnContainer.className = 'absolute top-1 left-1 right-1 flex justify-between opacity-0 group-hover:opacity-100 transition-opacity z-10';

                const leftBtns = document.createElement('div');
                
                const flipBtn = document.createElement('button');
                flipBtn.innerHTML = 'â†”ï¸';
                flipBtn.className = `rounded-full w-7 h-7 flex items-center justify-center font-bold text-xs transition-all duration-200 ${imgData.flipped ? 'bg-gray-900 text-white' : 'bg-white text-gray-800'}`;
                flipBtn.title = 'ì¢Œìš° ë°˜ì „';
                flipBtn.onclick = () => flipImage(index);
                leftBtns.appendChild(flipBtn);

                const rotateBtn = document.createElement('button');
                rotateBtn.innerHTML = 'ğŸ”„';
                rotateBtn.className = 'bg-white text-gray-800 rounded-full w-7 h-7 ml-1 flex items-center justify-center font-bold text-xs';
                rotateBtn.title = '90ë„ íšŒì „';
                rotateBtn.onclick = () => rotateImage(index);
                leftBtns.appendChild(rotateBtn);

                const upBtn = document.createElement('button');
                upBtn.textContent = 'â¬†';
                upBtn.className = 'bg-white rounded-full w-7 h-7 text-xs';
                upBtn.onclick = () => moveImage(index, -1);
                leftBtns.appendChild(upBtn);

                const downBtn = document.createElement('button');
                downBtn.textContent = 'â¬‡';
                downBtn.className = 'bg-white rounded-full w-7 h-7 text-xs ml-1';
                downBtn.onclick = () => moveImage(index, 1);
                leftBtns.appendChild(downBtn);

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '&times;';
                removeBtn.className = 'bg-red-500 text-white rounded-full w-7 h-7 flex items-center justify-center font-bold';
                removeBtn.onclick = () => removeImage(index);
                
                btnContainer.appendChild(leftBtns);
                btnContainer.appendChild(removeBtn);
                
                div.appendChild(img);
                div.appendChild(btnContainer);
                
                // ========================================================
                // âœ… ë¯¸ë¦¬ë³´ê¸° í„°ì¹˜/í´ë¦­ ì´ë²¤íŠ¸ (PC/ëª¨ë°”ì¼ í†µí•©)
                // ========================================================
                
                let tapTimer = null;
                let isTouchStarted = false;
                
                // í„°ì¹˜/ë§ˆìš°ìŠ¤ ë‹¤ìš´
                div.addEventListener('pointerdown', (e) => {
                    isTouchStarted = true;
                    
                    // ì´ë¯¸ ë“œë˜ê·¸ê°€ ì‹œì‘ë˜ì—ˆìœ¼ë©´ ë¬´ì‹œ
                    if (e.pointerType === 'touch' && draggedItem !== null) {
                        return;
                    }
                    
                    // ë²„íŠ¼ì„ í´ë¦­í–ˆìœ¼ë©´ ë¬´ì‹œ
                    if (e.target.closest('button')) {
                        return;
                    }
                    
                    // ë”ë¸”íƒ­ ê°ì§€ (ëª¨ë°”ì¼ì—ì„œ ì˜ë„ì¹˜ ì•Šì€ ì„ íƒ ë°©ì§€)
                    if (tapTimer) {
                        clearTimeout(tapTimer);
                        tapTimer = null;
                        // ë”ë¸”íƒ­ ë¬´ì‹œ
                        return;
                    }
                    
                    // ì‹±ê¸€íƒ­ ëŒ€ê¸°
                    tapTimer = setTimeout(() => {
                        if (!isTouchStarted) {
                            tapTimer = null;
                            return;
                        }
                        
                        e.stopPropagation();
                        
                        // ê²½ìš° 1: ìŠ¬ë¡¯ì´ ì„ íƒëœ ìƒíƒœì—ì„œ ë¯¸ë¦¬ë³´ê¸° í´ë¦­/í„°ì¹˜
                        if (selectedSlotIndex !== null) {
                            // êµí™˜ ì‹¤í–‰
                            [config.images[selectedSlotIndex], config.images[index]] =
                            [config.images[index], config.images[selectedSlotIndex]];
                            
                            selectedSlotIndex = null;
                            selectedPreviewIndex = null;
                            
                            renderImagePreviews();
                            drawCanvas();
                            
                            // í”¼ë“œë°±: ì§§ì€ ì§„ë™
                            if (navigator.vibrate) {
                                navigator.vibrate(100);
                            }
                            
                            tapTimer = null;
                            isTouchStarted = false;
                            return;
                        }
                        
                        // ê²½ìš° 2: ê°™ì€ ë¯¸ë¦¬ë³´ê¸°ë¥¼ ë‹¤ì‹œ í´ë¦­/í„°ì¹˜í•˜ë©´ ì„ íƒ í•´ì œ
                        if (selectedPreviewIndex === index) {
                            selectedPreviewIndex = null;
                            renderImagePreviews();
                            
                            tapTimer = null;
                            isTouchStarted = false;
                            return;
                        }
                        
                        // ê²½ìš° 3: ë¯¸ë¦¬ë³´ê¸° ì„ íƒ
                        selectedPreviewIndex = index;
                        selectedSlotIndex = null;
                        renderImagePreviews();
                        
                        // í”¼ë“œë°±: ì§§ì€ ì§„ë™ (ëª¨ë°”ì¼)
                        if (navigator.vibrate) {
                            navigator.vibrate(80);
                        }
                        
                        tapTimer = null;
                        isTouchStarted = false;
                    }, isMobileDevice ? 300 : 150);  // ëª¨ë°”ì¼ì€ ì¢€ ë” ê¸°ë‹¤ë ¸ë‹¤ê°€ (ë“œë˜ê·¸ vs íƒ­ êµ¬ë¶„)
                });
                
                // í„°ì¹˜/ë§ˆìš°ìŠ¤ ì—…
                div.addEventListener('pointerup', (e) => {
                    isTouchStarted = false;
                    // íƒ€ì´ë¨¸ëŠ” ìœ ì§€ (ì‹±ê¸€íƒ­ vs ë”ë¸”íƒ­ íŒì •ì„ ìœ„í•´)
                });
                
                // í„°ì¹˜/ë§ˆìš°ìŠ¤ ì·¨ì†Œ
                div.addEventListener('pointercancel', (e) => {
                    if (tapTimer) {
                        clearTimeout(tapTimer);
                        tapTimer = null;
                    }
                    isTouchStarted = false;
                });
                
                container.appendChild(div);
            });

            // ========================================================
            // 2ë‹¨ê³„: ë“œë˜ê·¸ ì•¤ ë“œë¡­ (ê¸°ì¡´ ì½”ë“œ)
            // ========================================================
            const items = container.querySelectorAll('.preview-item');
            
            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedItem = item;
                    setTimeout(() => item.classList.add('dragging'), 0);
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    draggedItem = null;
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    if (draggedItem && draggedItem !== item) {
                        const rect1 = draggedItem.getBoundingClientRect();
                        const rect2 = item.getBoundingClientRect();
                        
                        if (rect1.left + rect1.width / 2 < rect2.left + rect2.width / 2) {
                            item.parentNode.insertBefore(draggedItem, item);
                        } else {
                            item.parentNode.insertBefore(item, draggedItem);
                        }
                    }
                });
            });

            // ========================================================
            // 3ë‹¨ê³„: ë“œë¡­ ì´ë²¤íŠ¸ (ë°°ì—´ ì¬ì •ë ¬)
            // ========================================================
            
            container.addEventListener('drop', (e) => {
                e.preventDefault();
                
                const newOrder = Array.from(container.querySelectorAll('.preview-item'))
                    .map((item) => {
                        const oldIndex = parseInt(item.dataset.index);
                        return config.images[oldIndex];
                    });
                
                config.images = newOrder;
                
                selectedSlotIndex = null;
                selectedPreviewIndex = null;
                
                renderImagePreviews();
                drawCanvas();
            });

            document.getElementById('fileStatus').textContent = `${config.images.length} / ${MAX_IMAGES}ì¥ ì—…ë¡œë“œë¨.`;
        }

        // === getDragAfterElement ===
        // ì‘ì€ ì‚¬ì§„ë“¤ì„ ë“œë˜ê·¸ë¡œ ìˆœì„œ ë°”ê¿€ ë•Œ "ì—¬ê¸°ì— ë„£ì!" ìœ„ì¹˜ë¥¼ ì •í™•íˆ ì°¾ì•„ì£¼ëŠ” ë„ìš°ë¯¸ í•¨ìˆ˜ì˜ˆìš”.
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.preview-item:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) { return { offset: offset, element: child }; } 
                else { return closest; }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function flipImage(index) { config.images[index].flipped = !config.images[index].flipped; renderImagePreviews(); drawCanvas(); }
        function rotateImage(index) { config.images[index].rotation = (config.images[index].rotation + 90) % 360; renderImagePreviews(); drawCanvas(); }
        function removeImage(index) { config.images.splice(index, 1); renderImagePreviews(); drawCanvas(); }
        
        // === drawRoundedRect ===
        // ëª¨ì„œë¦¬ë¥¼ ë™ê·¸ë—ê²Œ ë§Œë“œëŠ” ì‚¬ê°í˜•ì„ ê·¸ë ¤ì£¼ëŠ” ë„ìš°ë¯¸ í•¨ìˆ˜ì˜ˆìš”. ì‚¬ì§„ ëª¨ì„œë¦¬ë¥¼ ë‘¥ê¸€ê²Œ í•  ë•Œ ì¨ìš”.
        function drawRoundedRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        function renderSlotOverlays() {
            const container = document.getElementById('slotOverlayContainer');
            const containerRect = document.getElementById('canvasContainer').getBoundingClientRect();
            
            // ========================================================
            // 1ë‹¨ê³„: í˜„ì¬ í•„ìš”í•œ ìŠ¬ë¡¯ë“¤ì„ ì²˜ë¦¬
            // ========================================================
            imageSlots.forEach(slot => {
                let el = slotOverlayCache.get(slot.index);
                
                // âœ… 2-1ë‹¨ê³„: ìŠ¬ë¡¯ì´ ì²˜ìŒ ìƒì„±ë˜ëŠ” ê²½ìš° (ìºì‹œì— ì—†ìŒ)
                if (!el) {
                    // ìƒˆ DOM ìš”ì†Œ ìƒì„±
                    el = document.createElement('div');
                    el.className = 'slot-overlay';
                    el.dataset.index = slot.index;
                    
                    // ì»¨í…Œì´ë„ˆì— ì¶”ê°€
                    container.appendChild(el);
                    
                    // ìºì‹œì— ì €ì¥ (ë‹¤ìŒë²ˆì— ì¬ì‚¬ìš©í•˜ê¸° ìœ„í•´)
                    slotOverlayCache.set(slot.index, el);
                    
                    // âš ï¸ ì¤‘ìš”: ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆëŠ” ì—¬ê¸°ì„œë§Œ ë“±ë¡!
                    //         (ì²˜ìŒ í•œ ë²ˆë§Œ, ì´í›„ë¡œëŠ” ìƒì„± ì•ˆ í•¨)
                    addDragEvents(el);
                }
                
                // âœ… 2-2ë‹¨ê³„: ìœ„ì¹˜ë§Œ ì—…ë°ì´íŠ¸ (ë§¤ í”„ë ˆì„ë§ˆë‹¤)
                //            DOM ìš”ì†ŒëŠ” ì¬ì‚¬ìš©í•˜ë¯€ë¡œ positionë§Œ ë³€ê²½
                el.style.left = (containerRect.left + slot.x) + 'px';
                el.style.top = (containerRect.top + slot.y) + 'px';
                el.style.width = slot.w + 'px';
                el.style.height = slot.h + 'px';
            });
            
            // ========================================================
            // 3ë‹¨ê³„: ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ìŠ¬ë¡¯ ì œê±°
            // ========================================================
            // ì˜ˆ: 4ì¥ ë ˆì´ì•„ì›ƒì—ì„œ 6ì¥ ë ˆì´ì•„ì›ƒìœ¼ë¡œ ë³€ê²½í–ˆì„ ë•Œ
            //     ìŠ¬ë¡¯ 4, 5ì˜ ì˜¤ë²„ë ˆì´ëŠ” ì œê±°í•´ì•¼ í•¨
            
            for (const [index, el] of slotOverlayCache.entries()) {
                // imageSlotsì— ì´ ì¸ë±ìŠ¤ê°€ ì—†ìœ¼ë©´ ìºì‹œì—ì„œ ì œê±°
                if (!imageSlots.find(s => s.index === index)) {
                    el.remove();                      // DOMì—ì„œ ì‚­ì œ
                    slotOverlayCache.delete(index);   // ìºì‹œì—ì„œ ì œê±°
                }
            }
        }

        function findSlotAtPosition(cx, cy) {
            const containerRect = document.getElementById('canvasContainer').getBoundingClientRect();
            
            return imageSlots.find(slot => {
                const x = containerRect.left + slot.x;
                const y = containerRect.top + slot.y;
                
                return (
                    cx > x &&
                    cx < x + slot.w &&
                    cy > y &&
                    cy < y + slot.h
                );
            });
        }

        function addDragEvents(el) {
            const containerRect = document.getElementById('canvasContainer').getBoundingClientRect();
            
            let draggingIndex = null;
            let slotTapTimer = null;
            let isSlotTouchStarted = false;

            // ========================================================
            // ë“œë˜ê·¸ ë¡œì§ (ê¸°ì¡´)
            // ========================================================
            
            el.addEventListener('pointerdown', e => {
                draggingIndex = Number(el.dataset.index);
                el.classList.add('dragging');
                el.setPointerCapture(e.pointerId);
            });

            el.addEventListener('pointerup', e => {
                el.releasePointerCapture(e.pointerId);
                el.classList.remove('dragging');

                const rect = el.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;

                const target = imageSlots.find(slot => {
                    const x = containerRect.left + slot.x;
                    const y = containerRect.top + slot.y;
                    
                    return (
                        cx > x &&
                        cx < x + slot.w &&
                        cy > y &&
                        cy < y + slot.h
                    );
                });

                if (target && target.index !== draggingIndex) {
                    [config.images[draggingIndex], config.images[target.index]] =
                    [config.images[target.index], config.images[draggingIndex]];
                    
                    drawCanvas();
                }

                draggingIndex = null;
            });
            
            // ========================================================
            // âœ… ì¶”ê°€: í„°ì¹˜/í´ë¦­ ì´ë²¤íŠ¸ (ìŠ¬ë¡¯ ì„ íƒ)
            // ========================================================
            
            el.addEventListener('pointerdown', (e) => {
                if (e.pointerType !== 'touch' && e.pointerType !== 'mouse') {
                    return;
                }
                
                isSlotTouchStarted = true;
                
                if (slotTapTimer) {
                    clearTimeout(slotTapTimer);
                    slotTapTimer = null;
                }
                
                slotTapTimer = setTimeout(() => {
                    if (!isSlotTouchStarted) {
                        slotTapTimer = null;
                        return;
                    }
                    
                    const slotIndex = Number(el.dataset.index);
                    
                    // ê²½ìš° 1: ë¯¸ë¦¬ë³´ê¸°ê°€ ì„ íƒëœ ìƒíƒœì—ì„œ ìŠ¬ë¡¯ í´ë¦­/í„°ì¹˜
                    if (selectedPreviewIndex !== null) {
                        [config.images[slotIndex], config.images[selectedPreviewIndex]] =
                        [config.images[selectedPreviewIndex], config.images[slotIndex]];
                        
                        selectedSlotIndex = null;
                        selectedPreviewIndex = null;
                        
                        renderImagePreviews();
                        drawCanvas();
                        
                        // í”¼ë“œë°±: ì§„ë™
                        if (navigator.vibrate) {
                            navigator.vibrate([100, 50, 100]);  // ì„±ê³µ íŒ¨í„´
                        }
                        
                        slotTapTimer = null;
                        isSlotTouchStarted = false;
                        return;
                    }
                    
                    // ê²½ìš° 2: ê°™ì€ ìŠ¬ë¡¯ì„ ë‹¤ì‹œ í´ë¦­/í„°ì¹˜í•˜ë©´ ì„ íƒ í•´ì œ
                    if (selectedSlotIndex === slotIndex) {
                        selectedSlotIndex = null;
                        drawCanvas();
                        
                        slotTapTimer = null;
                        isSlotTouchStarted = false;
                        return;
                    }
                    
                    // ê²½ìš° 3: ìŠ¬ë¡¯ ì„ íƒ
                    selectedSlotIndex = slotIndex;
                    selectedPreviewIndex = null;
                    drawCanvas();
                    
                    // í”¼ë“œë°±: ì§„ë™
                    if (navigator.vibrate) {
                        navigator.vibrate(80);
                    }
                    
                    slotTapTimer = null;
                    isSlotTouchStarted = false;
                }, isMobileDevice ? 300 : 150);
            });
            
            el.addEventListener('pointerup', (e) => {
                isSlotTouchStarted = false;
            });
            
            el.addEventListener('pointercancel', (e) => {
                if (slotTapTimer) {
                    clearTimeout(slotTapTimer);
                    slotTapTimer = null;
                }
                isSlotTouchStarted = false;
            });
        }

        // === resizeCanvas ===
        // í™”ë©´ í¬ê¸°ê°€ ë°”ë€Œê±°ë‚˜ ë ˆì´ì•„ì›ƒì„ ë°”ê¿€ ë•Œ ì‚¬ì§„ ë„£ëŠ” í° íŒ(ìº”ë²„ìŠ¤)ì„ ë”± ë§ê²Œ í¬ê¸° ì¡°ì •í•´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function drawCanvas() {
            // resizeCanvasì—ì„œ ì´ë¯¸ dpr ìŠ¤ì¼€ì¼ë§ì„ ì„¤ì •í–ˆìœ¼ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” dprì„ ë‹¤ì‹œ ê³±í•  í•„ìš” ì—†ìŒ
            const dW = canvas.displayWidth;
            const dH = canvas.displayHeight;

            // 1. ë°°ê²½ìƒ‰ ì±„ìš°ê¸°
            ctx.fillStyle = config.backgroundColor;
            ctx.fillRect(0, 0, dW, dH);

            // 2. í”„ë ˆì„ ì˜ì—­ ê³„ì‚° ë° ê·¸ë¦¬ê¸°
            const margin = dW * (config.frameMargin / 100);
            const fx = margin, fy = margin, fw = dW - 2 * margin, fh = dH - 2 * margin;
            ctx.fillStyle = config.frameColor;
            ctx.fillRect(fx, fy, fw, fh);

            // 3. ì‚¬ì§„ ìŠ¬ë¡¯ ê³„ì‚° ë° ê·¸ë¦¬ê¸°
            const p = fw * (config.imagePadding / 100);

            // â­â­â­ í•µì‹¬: ìŠ¬ë¡¯ ì •ë³´ ì´ˆê¸°í™”
            imageSlots = [];

            if (config.layout === '1x4') {
                const photoW = fw - 2 * p;
                const photoH = (fh - 5 * p) / 4;

                for (let i = 0; i < 4; i++) {
                    const x = fx + p;
                    const y = fy + p + i * (photoH + p);

                    imageSlots.push({ index: i, x, y, w: photoW, h: photoH });
                    drawPhotoSlot(i, x, y, photoW, photoH);
                }

            } else if (config.layout === '2x2') {
                const photoW = (fw - 3 * p) / 2;
                const photoH = (fh - 3 * p) / 2;

                const slots = [
                    { i: 0, x: fx + p,              y: fy + p },
                    { i: 1, x: fx + 2 * p + photoW, y: fy + p },
                    { i: 2, x: fx + p,              y: fy + 2 * p + photoH },
                    { i: 3, x: fx + 2 * p + photoW, y: fy + 2 * p + photoH }
                ];

                slots.forEach(s => {
                    imageSlots.push({ index: s.i, x: s.x, y: s.y, w: photoW, h: photoH });
                    drawPhotoSlot(s.i, s.x, s.y, photoW, photoH);
                });

            } else if (config.layout === '1+3') {
                const bigH = fh * 0.6 - p * 1.5;
                const smallH = fh * 0.4 - p * 1.5;

                // í° ì‚¬ì§„
                imageSlots.push({
                    index: 0,
                    x: fx + p,
                    y: fy + p,
                    w: fw - 2 * p,
                    h: bigH
                });
                drawPhotoSlot(0, fx + p, fy + p, fw - 2 * p, bigH);

                // ì‘ì€ ì‚¬ì§„ 3ê°œ
                const smallW = (fw - 4 * p) / 3;
                for (let i = 0; i < 3; i++) {
                    const x = fx + p + i * (smallW + p);
                    const y = fy + bigH + 2 * p;

                    imageSlots.push({ index: i + 1, x, y, w: smallW, h: smallH });
                    drawPhotoSlot(i + 1, x, y, smallW, smallH);
                }

            } else if (config.layout === '2+3') {
                const topH = fh * 0.45 - p * 1.5;
                const bottomH = fh * 0.55 - p * 1.5;
                const topW = (fw - 3 * p) / 2;
                const bottomW = (fw - 4 * p) / 3;

                // ìœ„ 2ê°œ
                for (let i = 0; i < 2; i++) {
                    const x = fx + p + i * (topW + p);
                    const y = fy + p;

                    imageSlots.push({ index: i, x, y, w: topW, h: topH });
                    drawPhotoSlot(i, x, y, topW, topH);
                }

                // ì•„ë˜ 3ê°œ
                for (let i = 0; i < 3; i++) {
                    const x = fx + p + i * (bottomW + p);
                    const y = fy + 2 * p + topH;

                    imageSlots.push({ index: i + 2, x, y, w: bottomW, h: bottomH });
                    drawPhotoSlot(i + 2, x, y, bottomW, bottomH);
                }

            } else if (config.layout === '2x3') {
                const photoW = (fw - 3 * p) / 2;
                const photoH = (fh - 4 * p) / 3;

                for (let i = 0; i < 6; i++) {
                    const row = Math.floor(i / 2);
                    const col = i % 2;

                    const x = fx + p + col * (photoW + p);
                    const y = fy + p + row * (photoH + p);

                    imageSlots.push({ index: i, x, y, w: photoW, h: photoH });
                    drawPhotoSlot(i, x, y, photoW, photoH);
                }

            } else if (config.layout === '3x2') {
                const photoW = (fw - 4 * p) / 3;
                const photoH = (fh - 3 * p) / 2;

                for (let i = 0; i < 6; i++) {
                    const row = Math.floor(i / 3);
                    const col = i % 3;

                    const x = fx + p + col * (photoW + p);
                    const y = fy + p + row * (photoH + p);

                    imageSlots.push({ index: i, x, y, w: photoW, h: photoH });
                    drawPhotoSlot(i, x, y, photoW, photoH);
                }
            }

            // 4. í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° - ë“œë˜ê·¸ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ
            if (!isDraggingText) {
                drawTextOnCanvas(dW, dH);
            }

            requestAnimationFrame(updateTextOverlay);

            // â­â­â­ ìº”ë²„ìŠ¤ ë“œë˜ê·¸ë¥¼ ìœ„í•œ overlay ìƒì„±
            renderSlotOverlays();
        }

        
        // === drawPhotoSlot ===
        // í•œ ì¹¸ í•œ ì¹¸ ì‚¬ì§„ ë„£ëŠ” ê³³ì— ì‚¬ì§„ì„ ì˜ˆì˜ê²Œ(í•„í„°Â·ë’¤ì§‘ê¸°Â·íšŒì „Â·ëª¨ì„œë¦¬ ë‘¥ê¸€ê²Œ) ë„£ê±°ë‚˜, ì‚¬ì§„ ì—†ì„ ë•ŒëŠ” "+" í‘œì‹œ ë„£ì–´ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function drawPhotoSlot(i, x, y, w, h) {
            const r = config.imageCornerRadius;
            if (i < config.images.length) {
                const {image: img, flipped, rotation, filter} = config.images[i];
                
                const imgRatio = img.width / img.height, slotRatio = w / h;
                let sx = 0, sy = 0, sWidth = img.width, sHeight = img.height;
                if (imgRatio > slotRatio) { sWidth = sHeight * slotRatio; sx = (img.width - sWidth) / 2; } 
                else { sHeight = sWidth / slotRatio; sy = (img.height - sHeight) / 2; }
                
                ctx.save();
                if (filter === 'grayscale') ctx.filter = 'grayscale(100%)';
                else if (filter === 'sepia') ctx.filter = 'sepia(100%)';
                else ctx.filter = 'none';

                drawRoundedRect(ctx, x, y, w, h, r); 
                ctx.clip();

                ctx.translate(x + w / 2, y + h / 2);
                if (flipped) ctx.scale(-1, 1);
                ctx.rotate(rotation * Math.PI / 180);
                
                ctx.drawImage(img, sx, sy, sWidth, sHeight, -w / 2, -h / 2, w, h);
                ctx.restore();
                
                // âœ… ì„ íƒëœ ìŠ¬ë¡¯ì— í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
                if (selectedSlotIndex === i) {
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 5;
                    drawRoundedRect(ctx, x, y, w, h, r);
                    ctx.stroke();
                    
                    // âœ… ì„ íƒ í‘œì‹œ (ì‘ì€ ì²´í¬ë§ˆí¬)
                    ctx.fillStyle = '#3b82f6';
                    ctx.beginPath();
                    ctx.arc(x + w - 15, y + 15, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('âœ“', x + w - 15, y + 15);
                }
            } else {
                ctx.fillStyle = '#e5e7eb'; 
                drawRoundedRect(ctx, x, y, w, h, r);
                ctx.fill();
                
                ctx.fillStyle = '#9ca3af';
                ctx.font = '30px Inter'; 
                ctx.textAlign = 'center'; 
                ctx.textBaseline = 'middle';
                ctx.fillText(`+`, x + w / 2, y + h / 2);
            }
        }
        
        // === drawTextOnCanvas ===
        // í° íŒì— ë©”ì¸ ê¸€ìì™€ ì‘ì€ ê¸€ìë¥¼ ì •í™•í•œ ìœ„ì¹˜Â·ìƒ‰Â·í¬ê¸°Â·í…Œë‘ë¦¬ë¡œ ê·¸ë ¤ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        function drawTextOnCanvas(W, H) {
            const { mainText, subText } = config;

            // ë©”ì¸ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            if (mainText.content) {
                const textX = W * mainText.x;
                const textY = H * mainText.y;
                
                ctx.font = `bold ${mainText.size}px "${mainText.font}"`;
                ctx.textAlign = 'center'; 
                ctx.textBaseline = 'middle'; 
                
                // NEW: Draw Stroke first if present
                if (mainText.strokeWidth > 0) {
                    ctx.strokeStyle = mainText.strokeColor;
                    // Stroke width is multiplied by 2 for better visibility/thickness
                    ctx.lineWidth = mainText.strokeWidth * 2; 
                    ctx.strokeText(mainText.content, textX, textY);
                }

                // Draw Fill
                ctx.fillStyle = mainText.color; 
                ctx.fillText(mainText.content, textX, textY);
            }

            // ë¶€ì œëª© í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            if (subText.content) {
                const subTextX = W * subText.x;
                const subTextY = H * subText.y;
                
                ctx.fillStyle = subText.color; 
                ctx.font = `normal ${subText.size}px "${subText.font}"`;
                ctx.textAlign = 'center'; 
                ctx.textBaseline = 'middle'; 
                ctx.fillText(subText.content, subTextX, subTextY);
            }
        }


        // === downloadImage ===
        // ì»´í“¨í„°ì—ì„œ "ì €ì¥!" ëˆ„ë¥´ë©´ ì˜ˆì˜ê³  í° ì‚¬ì´ì¦ˆì˜ ì™„ì„± ì‚¬ì§„ì„ íŒŒì¼ë¡œ ë‚´ë ¤ë°›ê²Œ í•´ ì£¼ëŠ” í•¨ìˆ˜ì˜ˆìš”.
        // ===== í—¬í¼ í•¨ìˆ˜: ë ˆì´ì•„ì›ƒë³„ ì¢…íš¡ë¹„ ê³„ì‚° =====
        function getAspectRatioByLayout(layout) {
            const ratios = {
                '1x4': 3,
                '2x2': 1.5,
                '1+3': 2,
                '2+3': 1.8,
                '2x3': 2.2,
                '3x2': 1.2,
            };
            return ratios[layout] || 3;
        }

        // ===== í—¬í¼ í•¨ìˆ˜: í¬ë§·ë³„ ì„¤ì • =====
        function getFormatConfig(format) {
            return {
                mimeType: format === 'jpeg' ? 'image/jpeg' : 'image/png',
                quality: format === 'jpeg' ? 0.95 : 1.0,
                extension: format,
            };
        }

        // ===== í—¬í¼ í•¨ìˆ˜: ê³ í™”ì§ˆ ìº”ë²„ìŠ¤ ìƒì„± =====
        function createHighResCanvas(layout) {
            const displayW = canvas.parentElement.getBoundingClientRect().width;
            const aspectRatio = getAspectRatioByLayout(layout);
            const displayH = displayW * aspectRatio;

            // ê³ í™”ì§ˆ ì¶œë ¥ì„ ìœ„í•´ ìµœì†Œ 1200px ë„ˆë¹„ë¡œ ì„¤ì •
            const renderW = 1200;
            const renderH = renderW * aspectRatio;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = renderW;
            tempCanvas.height = renderH;

            const tempCtx = tempCanvas.getContext('2d');
            const scaleX = renderW / displayW;
            const scaleY = renderH / displayH;
            tempCtx.scale(scaleX, scaleY);

            return {
                canvas: tempCanvas,
                ctx: tempCtx,
                scaleX,
                scaleY,
                renderW,
                renderH,
            };
        }

        // ===== í—¬í¼ í•¨ìˆ˜: Blobì„ íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œ =====
        function downloadBlobAsFile(blob, filename) {
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        // ===== ë©”ì¸ í•¨ìˆ˜: ì»´í“¨í„°ì—ì„œ ë‹¤ìš´ë¡œë“œ =====
        function downloadImage(format) {
            if (config.images.length === 0) {
                alert("ì‚¬ì§„ì„ ë¨¼ì € 1ì¥ ì´ìƒ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!");
                return;
            }

            showLoader(true);

            try {
                // ê³ í™”ì§ˆ ìº”ë²„ìŠ¤ ìƒì„±
                const { canvas: tempCanvas, ctx: tempCtx, scaleX, scaleY, renderW, renderH } = 
                    createHighResCanvas(config.layout);

                // ì„¤ì • ìŠ¤ëƒ…ìƒ·
                const configSnapshot = JSON.parse(JSON.stringify(config));

                // ê³ í™”ì§ˆ ë Œë”ë§
                drawCanvasOnContext(
                    tempCtx,
                    renderW / scaleX,
                    renderH / scaleY,
                    configSnapshot,
                    config.images
                );

                // í¬ë§· ì„¤ì •
                const { mimeType, quality } = getFormatConfig(format);

                // ë‹¤ìš´ë¡œë“œ
                const link = document.createElement('a');
                link.href = tempCanvas.toDataURL(mimeType, quality);
                link.download = `photobooth_${Date.now()}.${format}`;
                link.click();

                alert(`âœ… ë‹¤ìš´ë¡œë“œ ì™„ë£Œ! (${format.toUpperCase()})`);

            } catch (error) {
                console.error('Download error:', error);
                alert("âŒ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\n(íŒŒì¼ í¬ê¸°ê°€ í¬ê±°ë‚˜ ì‹œìŠ¤í…œ ê¶Œí•œ ë¬¸ì œ)");
            } finally {
                showLoader(false);
            }
        }

        // ===== ë©”ì¸ í•¨ìˆ˜: í•¸ë“œí°ì—ì„œ ê°¤ëŸ¬ë¦¬ ì €ì¥ ë˜ëŠ” ê³µìœ  =====
        async function saveToGallery(format) {
            if (config.images.length === 0) {
                alert("ì‚¬ì§„ì„ ë¨¼ì € 1ì¥ ì´ìƒ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!");
                return;
            }

            showLoader(true);

            try {
                // ê³ í™”ì§ˆ ìº”ë²„ìŠ¤ ìƒì„±
                const { canvas: tempCanvas, ctx: tempCtx, scaleX, scaleY, renderW, renderH } = 
                    createHighResCanvas(config.layout);

                // ì„¤ì • ìŠ¤ëƒ…ìƒ·
                const configSnapshot = JSON.parse(JSON.stringify(config));

                // ê³ í™”ì§ˆ ë Œë”ë§
                drawCanvasOnContext(
                    tempCtx,
                    renderW / scaleX,
                    renderH / scaleY,
                    configSnapshot,
                    config.images
                );

                // í¬ë§· ì„¤ì •
                const { mimeType, quality } = getFormatConfig(format);
                const filename = `photobooth_${Date.now()}.${format}`;

                // Blobìœ¼ë¡œ ë³€í™˜
                tempCanvas.toBlob(async (blob) => {
                    try {
                        const file = new File([blob], filename, { type: mimeType });

                        // Web Share API ì‹œë„ (ëª¨ë°”ì¼ ê°¤ëŸ¬ë¦¬ ì €ì¥)
                        if (navigator.share && navigator.canShare({ files: [file] })) {
                            await navigator.share({
                                files: [file],
                                title: 'í”„ë ˆì„ ë‹¤ì´ì–´ë¦¬ ê²°ê³¼ë¬¼',
                                text: 'íŠ¹ë³„í•œ ì¶”ì–µì„ ë‹´ì€ í¬í†  í”„ë ˆì„ì…ë‹ˆë‹¤.',
                            });
                            alert('âœ… ê°¤ëŸ¬ë¦¬ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
                        } else {
                            // Fallback: ì¼ë°˜ ë‹¤ìš´ë¡œë“œ
                            downloadBlobAsFile(blob, filename);
                            alert('âœ… íŒŒì¼ì´ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!');
                        }

                    } catch (error) {
                        console.error('Share error:', error);
                        // ì—ëŸ¬ ë°œìƒ ì‹œ ë‹¤ìš´ë¡œë“œë¡œ ëŒ€ì²´
                        downloadBlobAsFile(blob, filename);
                    }
                }, mimeType, quality);

            } catch (error) {
                console.error('Save error:', error);
                alert("âŒ ì´ë¯¸ì§€ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
            } finally {
                showLoader(false);
            }
        }

        // ===== í—¬í¼ í•¨ìˆ˜: Blobì„ íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œ =====
        function downloadBlobAsFile(blob, filename) {
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        // ===== í—¬í¼ í•¨ìˆ˜: ë¡œë” í‘œì‹œ/ìˆ¨ê¹€ =====
        function showLoader(show) {
            document.getElementById('loader').classList.toggle('hidden', !show);
            document.getElementById('loader').classList.toggle('flex', show);
        }

        // ===== ë‚´ë¶€ í•¨ìˆ˜: ë ˆì´ì•„ì›ƒë³„ ìŠ¬ë¡¯ ê·¸ë¦¬ê¸° =====
        function drawLayoutSlots(targetCtx, layout, slots) {
            const { fx, fy, fw, fh, p, drawSlot } = slots;
            
            // ========================================================
            // ê° ë ˆì´ì•„ì›ƒë³„ ìŠ¬ë¡¯ ìœ„ì¹˜ ê³„ì‚° ë° ê·¸ë¦¬ê¸°
            // ========================================================
            
            if (layout === '1x4') {
                // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                // â”‚    0    â”‚  ì„¸ë¡œ 4ê°œ
                // â”‚    1    â”‚
                // â”‚    2    â”‚
                // â”‚    3    â”‚
                // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                
                const photoW = fw - 2 * p;
                const photoH = (fh - 5 * p) / 4;
                
                for (let i = 0; i < 4; i++) {
                    const x = fx + p;
                    const y = fy + p + i * (photoH + p);
                    
                    // imageSlotsì— ì €ì¥ (ë“œë˜ê·¸ ìš©ë„)
                    imageSlots.push({ index: i, x, y, w: photoW, h: photoH });
                    
                    // ì‹¤ì œë¡œ ê·¸ë¦¬ê¸°
                    drawSlot(i, x, y, photoW, photoH);
                }
                
            } else if (layout === '2x2') {
                // â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
                // â”‚  0  â”‚  1  â”‚  2x2 ì •ì‚¬ê°í˜•
                // â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
                // â”‚  2  â”‚  3  â”‚
                // â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
                
                const photoW = (fw - 3 * p) / 2;
                const photoH = (fh - 3 * p) / 2;
                
                const positions = [
                    { i: 0, x: fx + p,              y: fy + p },
                    { i: 1, x: fx + 2 * p + photoW, y: fy + p },
                    { i: 2, x: fx + p,              y: fy + 2 * p + photoH },
                    { i: 3, x: fx + 2 * p + photoW, y: fy + 2 * p + photoH }
                ];
                
                positions.forEach(pos => {
                    imageSlots.push({ index: pos.i, x: pos.x, y: pos.y, w: photoW, h: photoH });
                    drawSlot(pos.i, pos.x, pos.y, photoW, photoH);
                });
                
            } else if (layout === '1+3') {
                // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                // â”‚      0       â”‚  í° ì‚¬ì§„ 1ê°œ
                // â”œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¤
                // â”‚  1  â”‚  2  â”‚  3  â”‚  ì‘ì€ ì‚¬ì§„ 3ê°œ
                // â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
                
                const bigH = fh * 0.6 - p * 1.5;
                const smallH = fh * 0.4 - p * 1.5;
                const smallW = (fw - 4 * p) / 3;
                
                // í° ì‚¬ì§„
                imageSlots.push({ index: 0, x: fx + p, y: fy + p, w: fw - 2 * p, h: bigH });
                drawSlot(0, fx + p, fy + p, fw - 2 * p, bigH);
                
                // ì‘ì€ ì‚¬ì§„ 3ê°œ
                for (let i = 0; i < 3; i++) {
                    const x = fx + p + i * (smallW + p);
                    const y = fy + bigH + 2 * p;
                    
                    imageSlots.push({ index: i + 1, x, y, w: smallW, h: smallH });
                    drawSlot(i + 1, x, y, smallW, smallH);
                }
                
            } else if (layout === '2+3') {
                // â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
                // â”‚  0   â”‚  1   â”‚  ìœ„ 2ê°œ
                // â”œâ”€â”€â”€â”€â”€â”¬â”´â”€â”€â”€â”€â”€â”¬â”¤
                // â”‚  2  â”‚  3   â”‚  4  â”‚  ì•„ë˜ 3ê°œ
                // â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
                
                const topH = fh * 0.45 - p * 1.5;
                const bottomH = fh * 0.55 - p * 1.5;
                const topW = (fw - 3 * p) / 2;
                const bottomW = (fw - 4 * p) / 3;
                
                // ìœ„ìª½ 2ê°œ
                for (let i = 0; i < 2; i++) {
                    const x = fx + p + i * (topW + p);
                    const y = fy + p;
                    
                    imageSlots.push({ index: i, x, y, w: topW, h: topH });
                    drawSlot(i, x, y, topW, topH);
                }
                
                // ì•„ë˜ìª½ 3ê°œ
                for (let i = 0; i < 3; i++) {
                    const x = fx + p + i * (bottomW + p);
                    const y = fy + 2 * p + topH;
                    
                    imageSlots.push({ index: i + 2, x, y, w: bottomW, h: bottomH });
                    drawSlot(i + 2, x, y, bottomW, bottomH);
                }
                
            } else if (layout === '2x3') {
                // â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
                // â”‚ 0  â”‚ 1  â”‚  ì„¸ë¡œ 3ì¤„
                // â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
                // â”‚ 2  â”‚ 3  â”‚  ê°€ë¡œ 2ì¹¸
                // â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
                // â”‚ 4  â”‚ 5  â”‚
                // â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
                
                const photoW = (fw - 3 * p) / 2;
                const photoH = (fh - 4 * p) / 3;
                
                for (let i = 0; i < 6; i++) {
                    const row = Math.floor(i / 2);
                    const col = i % 2;
                    
                    const x = fx + p + col * (photoW + p);
                    const y = fy + p + row * (photoH + p);
                    
                    imageSlots.push({ index: i, x, y, w: photoW, h: photoH });
                    drawSlot(i, x, y, photoW, photoH);
                }
                
            } else if (layout === '3x2') {
                // â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
                // â”‚ 0  â”‚ 1  â”‚ 2  â”‚  ì„¸ë¡œ 2ì¤„
                // â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
                // â”‚ 3  â”‚ 4  â”‚ 5  â”‚  ê°€ë¡œ 3ì¹¸
                // â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
                
                const photoW = (fw - 4 * p) / 3;
                const photoH = (fh - 3 * p) / 2;
                
                for (let i = 0; i < 6; i++) {
                    const row = Math.floor(i / 3);
                    const col = i % 3;
                    
                    const x = fx + p + col * (photoW + p);
                    const y = fy + p + row * (photoH + p);
                    
                    imageSlots.push({ index: i, x, y, w: photoW, h: photoH });
                    drawSlot(i, x, y, photoW, photoH);
                }
            }
        }

        // ===== ë‚´ë¶€ í•¨ìˆ˜: ì‚¬ì§„ ìŠ¬ë¡¯ ê·¸ë¦¬ê¸° =====
        function drawSlotImage(targetCtx, imageIndex, x, y, w, h, tempImages, tempConfig) {
            const r = tempConfig.imageCornerRadius;

            if (imageIndex < tempImages.length) {
                const { image: img, flipped, rotation, filter } = tempImages[imageIndex];

                const imgRatio = img.width / img.height;
                const slotRatio = w / h;

                let sx = 0, sy = 0, sWidth = img.width, sHeight = img.height;
                if (imgRatio > slotRatio) {
                    sWidth = sHeight * slotRatio;
                    sx = (img.width - sWidth) / 2;
                } else {
                    sHeight = sWidth / slotRatio;
                    sy = (img.height - sHeight) / 2;
                }

                targetCtx.save();

                // í•„í„° ì ìš©
                if (filter === 'grayscale') targetCtx.filter = 'grayscale(100%)';
                else if (filter === 'sepia') targetCtx.filter = 'sepia(100%)';
                else targetCtx.filter = 'none';

                // ë‘¥ê·¼ ëª¨ì„œë¦¬ í´ë¦¬í•‘
                drawRoundedRect(targetCtx, x, y, w, h, r);
                targetCtx.clip();

                // ë³€í™˜ ì ìš©
                targetCtx.translate(x + w / 2, y + h / 2);
                if (flipped) targetCtx.scale(-1, 1);
                targetCtx.rotate((rotation * Math.PI) / 180);

                targetCtx.drawImage(img, sx, sy, sWidth, sHeight, -w / 2, -h / 2, w, h);
                targetCtx.restore();
            } else {
                // í”Œë ˆì´ìŠ¤í™€ë” (ë¹ˆ ìŠ¬ë¡¯)
                targetCtx.fillStyle = '#e5e7eb';
                drawRoundedRect(targetCtx, x, y, w, h, r);
                targetCtx.fill();

                targetCtx.fillStyle = '#9ca3af';
                targetCtx.font = '30px Inter';
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillText('+', x + w / 2, y + h / 2);
            }
        }

        // ===== ë‚´ë¶€ í•¨ìˆ˜: í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° =====
        function drawTexts(targetCtx, tempConfig, dW, dH) {
            // ë©”ì¸ í…ìŠ¤íŠ¸
            if (tempConfig.mainText.content) {
                const textX = dW * tempConfig.mainText.x;
                const textY = dH * tempConfig.mainText.y;

                targetCtx.font = `bold ${tempConfig.mainText.size}px "${tempConfig.mainText.font}"`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';

                // ìŠ¤íŠ¸ë¡œí¬ (í…Œë‘ë¦¬)
                if (tempConfig.mainText.strokeWidth > 0) {
                    targetCtx.strokeStyle = tempConfig.mainText.strokeColor;
                    targetCtx.lineWidth = tempConfig.mainText.strokeWidth * 2;
                    targetCtx.strokeText(tempConfig.mainText.content, textX, textY);
                }

                // í…ìŠ¤íŠ¸ ì±„ìš°ê¸°
                targetCtx.fillStyle = tempConfig.mainText.color;
                targetCtx.fillText(tempConfig.mainText.content, textX, textY);
            }

            // ì„œë¸Œ í…ìŠ¤íŠ¸
            if (tempConfig.subText.content) {
                const subTextX = dW * tempConfig.subText.x;
                const subTextY = dH * tempConfig.subText.y;

                targetCtx.fillStyle = tempConfig.subText.color;
                targetCtx.font = `normal ${tempConfig.subText.size}px "${tempConfig.subText.font}"`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillText(tempConfig.subText.content, subTextX, subTextY);
            }
        }

        // ===== ë©”ì¸ í•¨ìˆ˜: ê³ í™”ì§ˆ ìº”ë²„ìŠ¤ ë Œë”ë§ =====
        function drawCanvasOnContext(targetCtx, dW, dH, tempConfig, tempImages) {
            // ========================================================
            // 1ë‹¨ê³„: ë°°ê²½ìƒ‰ ì¹ í•˜ê¸°
            // ========================================================
            targetCtx.fillStyle = tempConfig.backgroundColor;
            targetCtx.fillRect(0, 0, dW, dH);

            // ========================================================
            // 2ë‹¨ê³„: í”„ë ˆì„(í…Œë‘ë¦¬) ì¹ í•˜ê¸°
            // ========================================================
            const margin = dW * (tempConfig.frameMargin / 100);
            const fx = margin;           // í”„ë ˆì„ x
            const fy = margin;           // í”„ë ˆì„ y
            const fw = dW - 2 * margin;  // í”„ë ˆì„ width
            const fh = dH - 2 * margin;  // í”„ë ˆì„ height

            targetCtx.fillStyle = tempConfig.frameColor;
            targetCtx.fillRect(fx, fy, fw, fh);

            // ========================================================
            // 3ë‹¨ê³„: ì‚¬ì§„ ê°„ íŒ¨ë”© ê³„ì‚°
            // ========================================================
            const p = fw * (tempConfig.imagePadding / 100);

            // ========================================================
            // 4ë‹¨ê³„: imageSlots ë°°ì—´ ì´ˆê¸°í™” (ìƒˆë¡œ ê³„ì‚°)
            // ========================================================
            // imageSlotsëŠ” ì—¬ëŸ¬ ê³³ì—ì„œ ì‚¬ìš©ë˜ë¯€ë¡œ ë§¤ë²ˆ ì—…ë°ì´íŠ¸
            imageSlots = [];

            // ========================================================
            // 5ë‹¨ê³„: ìŠ¬ë¡¯ ê°ì²´ ì¤€ë¹„ (ì½œë°± í•¨ìˆ˜ í¬í•¨)
            // ========================================================
            const slots = {
                fx, fy, fw, fh, p,
                // drawSlot ì½œë°±: ê° ìŠ¬ë¡¯ì— ì‚¬ì§„ì„ ê·¸ë¦¼
                drawSlot: (i, x, y, w, h) => 
                    drawSlotImage(targetCtx, i, x, y, w, h, tempImages, tempConfig),
            };
            
            // ========================================================
            // 6ë‹¨ê³„: ë ˆì´ì•„ì›ƒì— ë”°ë¼ ìŠ¬ë¡¯ ë°°ì¹˜ ë° ê·¸ë¦¬ê¸°
            // ========================================================
            drawLayoutSlots(targetCtx, tempConfig.layout, slots);

            // ========================================================
            // 7ë‹¨ê³„: í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° (ì œëª© + ë‚ ì§œ)
            // ========================================================
            drawTexts(targetCtx, tempConfig, dW, dH);
        }

        // ===== ì´ë²¤íŠ¸: ì°½ ë¦¬ì‚¬ì´ì¦ˆ ê°ì§€ =====
        window.addEventListener('resize', () => {
            resizeCanvas();
            updateTextOverlay();
            drawCanvas();
        });
    </script>
</body>
</html>